namespace std::array;
    let<T> len: T[] -> int = [];
namespace std::prelude;
    enum Query {
        Input(int),
        Output(int, int),
        Hint(fe),
        DataIdentifier(int, int),
        None,
    }
    let set_hint: expr, (int -> std::prelude::Query) -> () = [];
namespace std::utils;
    let cross_product: int[] -> (int -> int)[] = |sizes| std::utils::cross_product_internal(1, 0, sizes);
    let cross_product_internal: int, int, int[] -> (int -> int)[] = |cycle_len, pos, sizes| if pos >= std::array::len::<int>(sizes) { [] } else { [|i| i / cycle_len % sizes[pos]] + std::utils::cross_product_internal(cycle_len * sizes[pos], pos + 1, sizes) };
namespace main(65536);
    col witness _operation_id;
    std::prelude::set_hint(main::_operation_id, query |i| std::prelude::Query::Hint(43));
    col fixed _block_enforcer_last_step = [0]* + [1];
    (1 - main::_block_enforcer_last_step) * (1 - main::instr_return) * (main::_operation_id' - main::_operation_id) = 0;
    col witness pc;
    col witness X0_1;
    col witness X0_2;
    col witness X1;
    col witness X2_1;
    col witness X2_2;
    col witness reg_write_X2_1_ALow;
    col witness ALow;
    col witness reg_write_X2_2_AHi;
    col witness AHi;
    col witness instr_shl;
    col witness instr_shr;
    col witness instr_assert_eq;
    main::instr_assert_eq * (main::X0_1 - main::X2_1) = 0;
    main::instr_assert_eq * (main::X0_2 - main::X2_2) = 0;
    col witness instr__jump_to_operation;
    col witness instr__reset;
    col witness instr__loop;
    col witness instr_return;
    col witness X0_1_const;
    col witness read_X0_1_ALow;
    main::X0_1 = main::read_X0_1_ALow * main::ALow + main::X0_1_const;
    col witness X0_2_const;
    col witness read_X0_2_AHi;
    main::X0_2 = main::read_X0_2_AHi * main::AHi + main::X0_2_const;
    col witness X1_const;
    main::X1 = main::X1_const;
    col witness X2_1_const;
    col witness X2_1_read_free;
    main::X2_1 = main::X2_1_const + main::X2_1_read_free * main::X2_1_free_value;
    col witness X2_2_const;
    col witness X2_2_read_free;
    main::X2_2 = main::X2_2_const + main::X2_2_read_free * main::X2_2_free_value;
    col fixed first_step = [1] + [0]*;
    main::AHi' = main::reg_write_X2_2_AHi * main::X2_2 + (1 - (main::reg_write_X2_2_AHi + main::instr__reset)) * main::AHi;
    main::ALow' = main::reg_write_X2_1_ALow * main::X2_1 + (1 - (main::reg_write_X2_1_ALow + main::instr__reset)) * main::ALow;
    col witness pc_update;
    main::pc_update = main::instr__jump_to_operation * main::_operation_id + main::instr__loop * main::pc + (1 - (main::instr__jump_to_operation + main::instr__loop + main::instr_return)) * (main::pc + 1);
    main::pc' = (1 - main::first_step') * main::pc_update;
    col witness X2_1_free_value;
    col witness X2_2_free_value;
    [main::pc, main::reg_write_X2_1_ALow, main::reg_write_X2_2_AHi, main::instr_shl, main::instr_shr, main::instr_assert_eq, main::instr__jump_to_operation, main::instr__reset, main::instr__loop, main::instr_return, main::X0_1_const, main::read_X0_1_ALow, main::X0_2_const, main::read_X0_2_AHi, main::X1_const, main::X2_1_const, main::X2_1_read_free, main::X2_2_const, main::X2_2_read_free] in [main__rom::p_line, main__rom::p_reg_write_X2_1_ALow, main__rom::p_reg_write_X2_2_AHi, main__rom::p_instr_shl, main__rom::p_instr_shr, main__rom::p_instr_assert_eq, main__rom::p_instr__jump_to_operation, main__rom::p_instr__reset, main__rom::p_instr__loop, main__rom::p_instr_return, main__rom::p_X0_1_const, main__rom::p_read_X0_1_ALow, main__rom::p_X0_2_const, main__rom::p_read_X0_2_AHi, main__rom::p_X1_const, main__rom::p_X2_1_const, main__rom::p_X2_1_read_free, main__rom::p_X2_2_const, main__rom::p_X2_2_read_free];
    main::instr_shl $ [0, main::X0_1, main::X0_2, main::X1, main::X2_1, main::X2_2] is main_shift16::latch * main_shift16::sel[0] $ [main_shift16::operation_id, main_shift16::ALow, main_shift16::AHi, main_shift16::B, main_shift16::CLow, main_shift16::CHi];
    main::instr_shr $ [1, main::X0_1, main::X0_2, main::X1, main::X2_1, main::X2_2] is main_shift16::latch * main_shift16::sel[1] $ [main_shift16::operation_id, main_shift16::ALow, main_shift16::AHi, main_shift16::B, main_shift16::CLow, main_shift16::CHi];
    col fixed _linker_first_step(i) { if i == 0 { 1 } else { 0 } };
    main::_linker_first_step * (main::_operation_id - 2) = 0;
namespace main__rom(65536);
    col fixed p_line = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43] + [43]*;
    col fixed p_X0_1_const = [0, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 0, 0] + [0]*;
    col fixed p_X0_2_const = [0, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 0, 0] + [0]*;
    col fixed p_X1_const = [0, 0, 0, 0, 1, 0, 4, 0, 8, 0, 12, 0, 16, 0, 20, 0, 24, 0, 28, 0, 31, 0, 0, 0, 1, 0, 4, 0, 8, 0, 12, 0, 16, 0, 20, 0, 24, 0, 28, 0, 31, 0, 0, 0] + [0]*;
    col fixed p_X2_1_const = [0, 0, 0, 4951, 0, 9902, 0, 13680, 0, 22272, 0, 28672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4951, 0, 35243, 0, 61749, 0, 53011, 0, 44273, 0, 39631, 0, 2476, 0, 154, 0, 9, 0, 1, 0, 0] + [0]*;
    col fixed p_X2_1_read_free = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
    col fixed p_X2_2_const = [0, 0, 0, 39631, 0, 13726, 0, 44273, 0, 53011, 0, 61749, 0, 4951, 0, 13680, 0, 22272, 0, 28672, 0, 32768, 0, 39631, 0, 19815, 0, 2476, 0, 154, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_X2_2_read_free = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
    col fixed p_instr__jump_to_operation = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_instr__loop = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] + [1]*;
    col fixed p_instr__reset = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_instr_assert_eq = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_instr_return = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0] + [0]*;
    col fixed p_instr_shl = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_instr_shr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
    col fixed p_read_X0_1_ALow = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_read_X0_2_AHi = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_reg_write_X2_1_ALow = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
    col fixed p_reg_write_X2_2_AHi = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
namespace main_byte_shift_16(65536);
    let bit_counts: int[] = [256, 32, 4, 2];
    let inputs: (int -> int)[] = std::utils::cross_product(main_byte_shift_16::bit_counts);
    let a: int -> int = main_byte_shift_16::inputs[0];
    let b: int -> int = main_byte_shift_16::inputs[1];
    let row: int -> int = main_byte_shift_16::inputs[2];
    let op: int -> int = main_byte_shift_16::inputs[3];
    let P_A: col = main_byte_shift_16::a;
    let P_B: col = main_byte_shift_16::b;
    let P_ROW: col = main_byte_shift_16::row;
    let P_operation: col = main_byte_shift_16::op;
    let c: int -> int = |i| match main_byte_shift_16::op(i) {
        0 => main_byte_shift_16::a(i) << main_byte_shift_16::b(i) + main_byte_shift_16::row(i) * 8,
        1 => main_byte_shift_16::a(i) << main_byte_shift_16::row(i) * 8 >> main_byte_shift_16::b(i),
    };
    col fixed P_CLow(i) { main_byte_shift_16::c(i) & 65535 };
    col fixed P_CHi(i) { main_byte_shift_16::c(i) >> 16 & 65535 };
namespace main_shift16(65536);
    col witness operation_id;
    (main_shift16::operation_id' - main_shift16::operation_id) * (1 - main_shift16::latch) = 0;
    col fixed latch(i) { if i % 4 == 3 { 1 } else { 0 } };
    col fixed FACTOR_ROW(i) { (i + 1) % 4 };
    col fixed FACTOR_ALow = [256, 0, 0, 1]*;
    col fixed FACTOR_AHi = [0, 1, 256, 0]*;
    col witness A_byte;
    col witness C_part_low;
    col witness C_part_hi;
    col witness ALow;
    col witness AHi;
    col witness B;
    col witness CLow;
    col witness CHi;
    main_shift16::ALow' = main_shift16::ALow * (1 - main_shift16::latch) + main_shift16::A_byte * main_shift16::FACTOR_ALow;
    main_shift16::AHi' = main_shift16::AHi * (1 - main_shift16::latch) + main_shift16::A_byte * main_shift16::FACTOR_AHi;
    (main_shift16::B' - main_shift16::B) * (1 - main_shift16::latch) = 0;
    main_shift16::CLow' = main_shift16::CLow * (1 - main_shift16::latch) + main_shift16::C_part_low;
    main_shift16::CHi' = main_shift16::CHi * (1 - main_shift16::latch) + main_shift16::C_part_hi;
    col witness sel[2];
    main_shift16::sel[0] * (1 - main_shift16::sel[0]) = 0;
    main_shift16::sel[1] * (1 - main_shift16::sel[1]) = 0;
    [main_shift16::operation_id', main_shift16::A_byte, main_shift16::B', main_shift16::FACTOR_ROW, main_shift16::C_part_low, main_shift16::C_part_hi] in [main_byte_shift_16::P_operation, main_byte_shift_16::P_A, main_byte_shift_16::P_B, main_byte_shift_16::P_ROW, main_byte_shift_16::P_CLow, main_byte_shift_16::P_CHi];
