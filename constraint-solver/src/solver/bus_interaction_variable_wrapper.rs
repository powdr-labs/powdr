use std::{collections::BTreeMap, fmt::Display};

use powdr_number::FieldElement;
use std::hash::Hash;

use crate::{
    constraint_system::{BusInteraction, ConstraintSystem},
    quadratic_symbolic_expression::QuadraticSymbolicExpression,
    solver::SolveResult,
};

/// A wrapped variable: Either a regular variable or a bus interaction field.
#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub enum Variable<V> {
    Variable(V),
    BusInteractionField(usize, usize),
}

impl<V: Display> Display for Variable<V> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Variable::Variable(v) => write!(f, "{v}"),
            Variable::BusInteractionField(bus_index, field_index) => {
                write!(f, "BusInteractionField({bus_index}, {field_index})")
            }
        }
    }
}

/// An assignment of a wrapped variable.
pub type IntermediateAssignment<T, V> = (Variable<V>, QuadraticSymbolicExpression<T, Variable<V>>);

pub struct BusInteractionVariableWrapper<T: FieldElement, V> {
    pub bus_interaction_vars: BTreeMap<Variable<V>, QuadraticSymbolicExpression<T, V>>,
}

impl<T: FieldElement, V: Ord + Clone + Hash + Eq + Display> BusInteractionVariableWrapper<T, V> {
    pub fn new(
        constraint_system: ConstraintSystem<T, V>,
    ) -> (Self, ConstraintSystem<T, Variable<V>>) {
        let mut new_constraints = Vec::new();
        let mut bus_interaction_vars = BTreeMap::new();
        let bus_interactions = constraint_system
            .bus_interactions
            .iter()
            .enumerate()
            .map(|(bus_interaction_index, bus_interaction)| {
                BusInteraction::from_iter(bus_interaction.fields().enumerate().map(
                    |(field_index, expr)| {
                        let transformed_expr =
                            expr.transform_var_type(&mut |v| Variable::Variable(v.clone()));
                        let v = Variable::BusInteractionField(bus_interaction_index, field_index);
                        new_constraints.push(
                            transformed_expr
                                - QuadraticSymbolicExpression::from_unknown_variable(v.clone()),
                        );
                        bus_interaction_vars.insert(v.clone(), expr.clone());
                        QuadraticSymbolicExpression::from_unknown_variable(v)
                    },
                ))
            })
            .collect();
        let constraint_system = ConstraintSystem {
            algebraic_constraints: constraint_system
                .algebraic_constraints
                .iter()
                .map(|expr| expr.transform_var_type(&mut |v| Variable::Variable(v.clone())))
                .chain(new_constraints)
                .collect(),
            bus_interactions,
        };
        (
            Self {
                bus_interaction_vars,
            },
            constraint_system,
        )
    }

    pub fn finalize(mut self, assignments: Vec<IntermediateAssignment<T, V>>) -> SolveResult<T, V> {
        for (variable, expr) in &assignments {
            // Apply any assignments to the bus interaction field definitions.
            if let Variable::BusInteractionField(..) = variable {
                if let Some(value) = expr.try_to_number() {
                    self.bus_interaction_vars
                        .insert(variable.clone(), value.into());
                } else {
                    // Non-concrete assignments are only generated by the `quadratic_equivalences` module,
                    // and bus interaction fields should only appear in bus interactions and constraints
                    // of the form <bus interaction field> = <expression>, which would not lead to a
                    // quadratic equivalence.
                    unreachable!();
                }
            }
        }

        // Unwrap assignments. Note that this uses the updated bus interaction field definitions.
        let assignments = assignments
            .into_iter()
            .filter_map(|(v, expr)| match v {
                Variable::Variable(v) => Some((v, self.unwrap_expression(expr))),
                Variable::BusInteractionField(..) => None,
            })
            .collect();

        // If a bus interaction field can be assigned a concrete value, report this to the caller.
        let bus_field_assignments = self
            .bus_interaction_vars
            .into_iter()
            .filter_map(|(v, expr)| match (v, expr.try_to_number()) {
                (Variable::BusInteractionField(bus_index, field_index), Some(value)) => {
                    Some(((bus_index, field_index), value))
                }
                _ => None,
            })
            .collect();

        SolveResult {
            assignments,
            bus_field_assignments,
        }
    }

    fn unwrap_expression(
        &self,
        mut expr: QuadraticSymbolicExpression<T, Variable<V>>,
    ) -> QuadraticSymbolicExpression<T, V> {
        // Need to materialize because of borrow checker
        let variables = expr
            .referenced_unknown_variables()
            .cloned()
            .collect::<Vec<_>>();
        // Substitute any bus interaction fields with their definitions
        for v in variables {
            if let Variable::BusInteractionField(..) = v {
                let definition = self
                    .bus_interaction_vars
                    .get(&v)
                    .unwrap()
                    .transform_var_type(&mut |v| Variable::Variable(v.clone()));
                expr.substitute_by_unknown(&v, &definition);
            }
        }
        // Unwrap the variable type
        let expr = expr.transform_var_type(&mut |v| match v {
            Variable::Variable(v) => v.clone(),
            Variable::BusInteractionField(..) => {
                unreachable!("Bus interaction fields should have been substituted");
            }
        });
        expr
    }
}
