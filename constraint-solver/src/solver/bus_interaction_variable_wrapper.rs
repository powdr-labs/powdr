use std::{collections::BTreeMap, fmt::Display};

use itertools::Itertools;
use std::hash::Hash;

use crate::{
    constraint_system::{BusInteraction, ConstraintSystem},
    grouped_expression::GroupedExpression,
    runtime_constant::{RuntimeConstant, Substitutable, VarTransformable},
    solver::{SolveResult, VariableAssignment},
};

/// A wrapped variable: Either a regular variable or a bus interaction field.
#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub enum Variable<V> {
    Variable(V),
    BusInteractionField(usize, usize),
}

impl<V: Display> Display for Variable<V> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Variable::Variable(v) => write!(f, "{v}"),
            Variable::BusInteractionField(bus_index, field_index) => {
                write!(f, "BusInteractionField({bus_index}, {field_index})")
            }
        }
    }
}

pub struct BusInteractionVariableWrapper<T, V> {
    pub bus_interaction_vars: BTreeMap<Variable<V>, GroupedExpression<T, V>>,
}

impl<T, V: Ord + Clone + Hash + Eq + Display> BusInteractionVariableWrapper<T, V>
where
    T: RuntimeConstant + VarTransformable<V, Variable<V>> + Display,
    T::Transformed: RuntimeConstant
        + VarTransformable<Variable<V>, V, Transformed = T>
        + Substitutable<Variable<V>>,
{
    pub fn replace_bus_interaction_expressions(
        constraint_system: ConstraintSystem<T, V>,
    ) -> (Self, ConstraintSystem<T::Transformed, Variable<V>>) {
        let mut new_constraints = Vec::new();
        let mut bus_interaction_vars = BTreeMap::new();
        let bus_interactions = constraint_system
            .bus_interactions
            .iter()
            .enumerate()
            .map(|(bus_interaction_index, bus_interaction)| {
                BusInteraction::from_iter(bus_interaction.fields().enumerate().map(
                    |(field_index, expr)| {
                        let transformed_expr =
                            expr.transform_var_type(&mut |v| Variable::Variable(v.clone()));
                        let v = Variable::BusInteractionField(bus_interaction_index, field_index);
                        new_constraints.push(
                            transformed_expr - GroupedExpression::from_unknown_variable(v.clone()),
                        );
                        bus_interaction_vars.insert(v.clone(), expr.clone());
                        GroupedExpression::from_unknown_variable(v)
                    },
                ))
            })
            .collect();
        let constraint_system = ConstraintSystem {
            algebraic_constraints: constraint_system
                .algebraic_constraints
                .iter()
                .map(|expr| expr.transform_var_type(&mut |v| Variable::Variable(v.clone())))
                .chain(new_constraints)
                .collect(),
            bus_interactions,
        };
        (
            Self {
                bus_interaction_vars,
            },
            constraint_system,
        )
    }

    pub fn finalize(
        mut self,
        assignments: Vec<VariableAssignment<T::Transformed, Variable<V>>>,
    ) -> SolveResult<T, V> {
        for (variable, expr) in &assignments {
            // Apply any assignments to the bus interaction field definitions.
            if let Variable::BusInteractionField(..) = variable {
                // Non-concrete assignments are only generated by the `quadratic_equivalences` module,
                // and bus interaction fields should only appear in bus interactions and constraints
                // of the form <bus interaction field> = <expression>, which would not lead to a
                // quadratic equivalence.
                // So we only expect concrete values here, but we need to do some trickery
                // to translate types which we expect to be equal anyway.
                let value: T::FieldType = expr
                    .try_to_known()
                    .unwrap()
                    .transform_var_type(&mut |_| unreachable!())
                    .try_to_number()
                    .unwrap();
                self.bus_interaction_vars
                    .insert(variable.clone(), GroupedExpression::from_number(value));
            }
        }

        // Unwrap assignments. Note that this uses the updated bus interaction field definitions.
        let assignments = assignments
            .into_iter()
            .filter_map(|(v, expr)| match v {
                Variable::Variable(v) => {
                    Some((v, unwrap_expression(&self.bus_interaction_vars, expr)))
                }
                Variable::BusInteractionField(..) => None,
            })
            .collect();

        // If a bus interaction field can be assigned a concrete value, report this to the caller.
        let bus_field_assignments = self
            .bus_interaction_vars
            .into_iter()
            .filter_map(|(v, expr)| match (v, expr.try_to_number()) {
                (Variable::BusInteractionField(bus_index, field_index), Some(value)) => {
                    Some(((bus_index, field_index), value))
                }
                _ => None,
            })
            .collect();

        SolveResult {
            assignments,
            bus_field_assignments,
        }
    }
}

fn unwrap_expression<T, V>(
    bus_interaction_vars: &BTreeMap<Variable<V>, GroupedExpression<T, V>>,
    mut expr: GroupedExpression<T::Transformed, Variable<V>>,
) -> GroupedExpression<T, V>
where
    T: RuntimeConstant + VarTransformable<V, Variable<V>> + Display,
    T::Transformed: RuntimeConstant
        + VarTransformable<Variable<V>, V, Transformed = T>
        + Substitutable<Variable<V>>,
    V: Ord + Clone + Hash + Eq,
{
    // Need to materialize because of borrow checker
    let variables = expr
        .referenced_unknown_variables()
        .filter(|v| matches!(v, Variable::BusInteractionField(..)))
        .cloned()
        .unique()
        .collect::<Vec<_>>();
    // Substitute any bus interaction fields with their definitions
    for v in variables {
        let Variable::BusInteractionField(..) = v else {
            unreachable!()
        };
        let definition = bus_interaction_vars
            .get(&v)
            .unwrap()
            .transform_var_type(&mut |v| Variable::Variable(v.clone()));
        expr.substitute_by_unknown(&v, &definition);
    }
    // Unwrap the variable type
    let expr = expr.transform_var_type(&mut |v| match v {
        Variable::Variable(v) => v.clone(),
        Variable::BusInteractionField(..) => {
            unreachable!("Bus interaction fields should have been substituted");
        }
    });
    expr
}
