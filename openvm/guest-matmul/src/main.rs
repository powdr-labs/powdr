#![cfg_attr(target_os = "zkvm", no_main)]
#![cfg_attr(target_os = "zkvm", no_std)]

openvm::entry!(main);

use openvm::io::reveal_u32;

pub fn main() {
    loop_test_matrix();
}

const SIZE: usize = 6;

type Mat = [[i32; SIZE]; SIZE];

#[inline(never)]
fn matrix_multiply_unrolled(a: &Mat, b: &Mat, c: &mut Mat) {
    c[0][0] = a[0][0] * b[0][0]
        + a[0][1] * b[1][0]
        + a[0][2] * b[2][0]
        + a[0][3] * b[3][0]
        + a[0][4] * b[4][0]
        + a[0][5] * b[5][0];
    c[0][1] = a[0][0] * b[0][1]
        + a[0][1] * b[1][1]
        + a[0][2] * b[2][1]
        + a[0][3] * b[3][1]
        + a[0][4] * b[4][1]
        + a[0][5] * b[5][1];
    c[0][2] = a[0][0] * b[0][2]
        + a[0][1] * b[1][2]
        + a[0][2] * b[2][2]
        + a[0][3] * b[3][2]
        + a[0][4] * b[4][2]
        + a[0][5] * b[5][2];
    c[0][3] = a[0][0] * b[0][3]
        + a[0][1] * b[1][3]
        + a[0][2] * b[2][3]
        + a[0][3] * b[3][3]
        + a[0][4] * b[4][3]
        + a[0][5] * b[5][3];
    c[0][4] = a[0][0] * b[0][4]
        + a[0][1] * b[1][4]
        + a[0][2] * b[2][4]
        + a[0][3] * b[3][4]
        + a[0][4] * b[4][4]
        + a[0][5] * b[5][4];
    c[0][5] = a[0][0] * b[0][5]
        + a[0][1] * b[1][5]
        + a[0][2] * b[2][5]
        + a[0][3] * b[3][5]
        + a[0][4] * b[4][5]
        + a[0][5] * b[5][5];

    c[1][0] = a[1][0] * b[0][0]
        + a[1][1] * b[1][0]
        + a[1][2] * b[2][0]
        + a[1][3] * b[3][0]
        + a[1][4] * b[4][0]
        + a[1][5] * b[5][0];
    c[1][1] = a[1][0] * b[0][1]
        + a[1][1] * b[1][1]
        + a[1][2] * b[2][1]
        + a[1][3] * b[3][1]
        + a[1][4] * b[4][1]
        + a[1][5] * b[5][1];
    c[1][2] = a[1][0] * b[0][2]
        + a[1][1] * b[1][2]
        + a[1][2] * b[2][2]
        + a[1][3] * b[3][2]
        + a[1][4] * b[4][2]
        + a[1][5] * b[5][2];
    c[1][3] = a[1][0] * b[0][3]
        + a[1][1] * b[1][3]
        + a[1][2] * b[2][3]
        + a[1][3] * b[3][3]
        + a[1][4] * b[4][3]
        + a[1][5] * b[5][3];
    c[1][4] = a[1][0] * b[0][4]
        + a[1][1] * b[1][4]
        + a[1][2] * b[2][4]
        + a[1][3] * b[3][4]
        + a[1][4] * b[4][4]
        + a[1][5] * b[5][4];
    c[1][5] = a[1][0] * b[0][5]
        + a[1][1] * b[1][5]
        + a[1][2] * b[2][5]
        + a[1][3] * b[3][5]
        + a[1][4] * b[4][5]
        + a[1][5] * b[5][5];

    c[2][0] = a[2][0] * b[0][0]
        + a[2][1] * b[1][0]
        + a[2][2] * b[2][0]
        + a[2][3] * b[3][0]
        + a[2][4] * b[4][0]
        + a[2][5] * b[5][0];
    c[2][1] = a[2][0] * b[0][1]
        + a[2][1] * b[1][1]
        + a[2][2] * b[2][1]
        + a[2][3] * b[3][1]
        + a[2][4] * b[4][1]
        + a[2][5] * b[5][1];
    c[2][2] = a[2][0] * b[0][2]
        + a[2][1] * b[1][2]
        + a[2][2] * b[2][2]
        + a[2][3] * b[3][2]
        + a[2][4] * b[4][2]
        + a[2][5] * b[5][2];
    c[2][3] = a[2][0] * b[0][3]
        + a[2][1] * b[1][3]
        + a[2][2] * b[2][3]
        + a[2][3] * b[3][3]
        + a[2][4] * b[4][3]
        + a[2][5] * b[5][3];
    c[2][4] = a[2][0] * b[0][4]
        + a[2][1] * b[1][4]
        + a[2][2] * b[2][4]
        + a[2][3] * b[3][4]
        + a[2][4] * b[4][4]
        + a[2][5] * b[5][4];
    c[2][5] = a[2][0] * b[0][5]
        + a[2][1] * b[1][5]
        + a[2][2] * b[2][5]
        + a[2][3] * b[3][5]
        + a[2][4] * b[4][5]
        + a[2][5] * b[5][5];

    c[3][0] = a[3][0] * b[0][0]
        + a[3][1] * b[1][0]
        + a[3][2] * b[2][0]
        + a[3][3] * b[3][0]
        + a[3][4] * b[4][0]
        + a[3][5] * b[5][0];
    c[3][1] = a[3][0] * b[0][1]
        + a[3][1] * b[1][1]
        + a[3][2] * b[2][1]
        + a[3][3] * b[3][1]
        + a[3][4] * b[4][1]
        + a[3][5] * b[5][1];
    c[3][2] = a[3][0] * b[0][2]
        + a[3][1] * b[1][2]
        + a[3][2] * b[2][2]
        + a[3][3] * b[3][2]
        + a[3][4] * b[4][2]
        + a[3][5] * b[5][2];
    c[3][3] = a[3][0] * b[0][3]
        + a[3][1] * b[1][3]
        + a[3][2] * b[2][3]
        + a[3][3] * b[3][3]
        + a[3][4] * b[4][3]
        + a[3][5] * b[5][3];
    c[3][4] = a[3][0] * b[0][4]
        + a[3][1] * b[1][4]
        + a[3][2] * b[2][4]
        + a[3][3] * b[3][4]
        + a[3][4] * b[4][4]
        + a[3][5] * b[5][4];
    c[3][5] = a[3][0] * b[0][5]
        + a[3][1] * b[1][5]
        + a[3][2] * b[2][5]
        + a[3][3] * b[3][5]
        + a[3][4] * b[4][5]
        + a[3][5] * b[5][5];

    c[4][0] = a[4][0] * b[0][0]
        + a[4][1] * b[1][0]
        + a[4][2] * b[2][0]
        + a[4][3] * b[3][0]
        + a[4][4] * b[4][0]
        + a[4][5] * b[5][0];
    c[4][1] = a[4][0] * b[0][1]
        + a[4][1] * b[1][1]
        + a[4][2] * b[2][1]
        + a[4][3] * b[3][1]
        + a[4][4] * b[4][1]
        + a[4][5] * b[5][1];
    c[4][2] = a[4][0] * b[0][2]
        + a[4][1] * b[1][2]
        + a[4][2] * b[2][2]
        + a[4][3] * b[3][2]
        + a[4][4] * b[4][2]
        + a[4][5] * b[5][2];
    c[4][3] = a[4][0] * b[0][3]
        + a[4][1] * b[1][3]
        + a[4][2] * b[2][3]
        + a[4][3] * b[3][3]
        + a[4][4] * b[4][3]
        + a[4][5] * b[5][3];
    c[4][4] = a[4][0] * b[0][4]
        + a[4][1] * b[1][4]
        + a[4][2] * b[2][4]
        + a[4][3] * b[3][4]
        + a[4][4] * b[4][4]
        + a[4][5] * b[5][4];
    c[4][5] = a[4][0] * b[0][5]
        + a[4][1] * b[1][5]
        + a[4][2] * b[2][5]
        + a[4][3] * b[3][5]
        + a[4][4] * b[4][5]
        + a[4][5] * b[5][5];

    c[5][0] = a[5][0] * b[0][0]
        + a[5][1] * b[1][0]
        + a[5][2] * b[2][0]
        + a[5][3] * b[3][0]
        + a[5][4] * b[4][0]
        + a[5][5] * b[5][0];
    c[5][1] = a[5][0] * b[0][1]
        + a[5][1] * b[1][1]
        + a[5][2] * b[2][1]
        + a[5][3] * b[3][1]
        + a[5][4] * b[4][1]
        + a[5][5] * b[5][1];
    c[5][2] = a[5][0] * b[0][2]
        + a[5][1] * b[1][2]
        + a[5][2] * b[2][2]
        + a[5][3] * b[3][2]
        + a[5][4] * b[4][2]
        + a[5][5] * b[5][2];
    c[5][3] = a[5][0] * b[0][3]
        + a[5][1] * b[1][3]
        + a[5][2] * b[2][3]
        + a[5][3] * b[3][3]
        + a[5][4] * b[4][3]
        + a[5][5] * b[5][3];
    c[5][4] = a[5][0] * b[0][4]
        + a[5][1] * b[1][4]
        + a[5][2] * b[2][4]
        + a[5][3] * b[3][4]
        + a[5][4] * b[4][4]
        + a[5][5] * b[5][4];
    c[5][5] = a[5][0] * b[0][5]
        + a[5][1] * b[1][5]
        + a[5][2] * b[2][5]
        + a[5][3] * b[3][5]
        + a[5][4] * b[4][5]
        + a[5][5] * b[5][5];
}

#[inline(never)]
fn test_matrix() {
    let a: Mat = [
        [1, 2, 3, 4, 5, 6],
        [7, 8, 9, 10, 11, 12],
        [13, 14, 15, 16, 17, 18],
        [19, 20, 21, 22, 23, 24],
        [25, 26, 27, 28, 29, 30],
        [31, 32, 33, 34, 35, 36],
    ];

    let b: Mat = [
        [37, 38, 39, 40, 41, 42],
        [43, 44, 45, 46, 47, 48],
        [49, 50, 51, 52, 53, 54],
        [55, 56, 57, 58, 59, 60],
        [61, 62, 63, 64, 65, 66],
        [67, 68, 69, 70, 71, 72],
    ];

    let mut c: Mat = [[0; SIZE]; SIZE];

    matrix_multiply_unrolled(&a, &b, &mut c);

    assert_eq!(c[0][0], 1197);
    reveal_u32(c[0][0] as u32, 0);
    reveal_u32(c[5][5] as u32, 1);
}

#[inline(never)]
fn loop_test_matrix() {
    for _ in 0..8000 {
        test_matrix();
    }
}
