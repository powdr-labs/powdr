namespace std::array;
    let<T1, T2> fold: T1[], T2, (T2, T1 -> T2) -> T2 = |arr, initial, folder| std::utils::fold::<T1, T2>(std::array::len::<T1>(arr), |i| arr[i], initial, folder);
    let<T> len: T[] -> int = [];
    let<T1, T2> map_enumerated: T1[], (int, T1 -> T2) -> T2[] = |arr, f| std::array::new::<T2>(std::array::len::<T1>(arr), |i| f(i, arr[i]));
    let<T> new: int, (int -> T) -> T[] = |length, f| std::utils::fold::<T, T[]>(length, f, [], |acc, e| acc + [e]);
    let<T: Add + FromLiteral> sum: T[] -> T = |arr| std::array::fold::<T, T>(arr, 0, |a, b| a + b);
namespace std::convert;
    let fe = [];
    let int = [];
namespace std::prelude;
    enum Query {
        Input(int),
        Output(int, int),
        Hint(fe),
        DataIdentifier(int, int),
        None,
    }
    let set_hint: expr, (int -> std::prelude::Query) -> () = [];
namespace std::prover;
    let eval: expr -> fe = [];
namespace std::utils;
    let<T1, T2> fold: int, (int -> T1), T2, (T2, T1 -> T2) -> T2 = |length, f, initial, folder| if length <= 0 { initial } else { folder(std::utils::fold::<T1, T2>(length - 1, f, initial, folder), f(length - 1)) };
namespace main(65536);
    col witness _operation_id;
    std::prelude::set_hint(main::_operation_id, query |i| std::prelude::Query::Hint(14));
    col fixed _block_enforcer_last_step = [0]* + [1];
    (1 - main::_block_enforcer_last_step) * (main::_operation_id' - main::_operation_id) = 0;
    col witness pc;
    col witness A0;
    col witness A1;
    col witness B0;
    col witness B1;
    col witness C0;
    col witness C1;
    col witness D0;
    col witness D1;
    col witness reg_write_C0_t_0_0;
    col witness t_0_0;
    col witness reg_write_C1_t_0_1;
    col witness t_0_1;
    col witness reg_write_D0_t_1_0;
    col witness t_1_0;
    col witness reg_write_D1_t_1_1;
    col witness t_1_1;
    col witness instr_mul;
    col witness instr_div;
    col witness instr_assert_eq;
    main::instr_assert_eq * (main::A0 - main::C0) = 0;
    main::instr_assert_eq * (main::A1 - main::C1) = 0;
    main::instr_assert_eq * (main::B0 - main::D0) = 0;
    main::instr_assert_eq * (main::B1 - main::D1) = 0;
    col witness instr__jump_to_operation;
    col witness instr__reset;
    col witness instr__loop;
    col witness A0_const;
    col witness read_A0_t_0_0;
    main::A0 = main::read_A0_t_0_0 * main::t_0_0 + main::A0_const;
    col witness A1_const;
    col witness read_A1_t_0_1;
    main::A1 = main::read_A1_t_0_1 * main::t_0_1 + main::A1_const;
    col witness B0_const;
    col witness read_B0_t_1_0;
    main::B0 = main::read_B0_t_1_0 * main::t_1_0 + main::B0_const;
    col witness B1_const;
    col witness read_B1_t_1_1;
    main::B1 = main::read_B1_t_1_1 * main::t_1_1 + main::B1_const;
    col witness C0_const;
    col witness C0_read_free;
    main::C0 = main::C0_const + main::C0_read_free * main::C0_free_value;
    col witness C1_const;
    col witness C1_read_free;
    main::C1 = main::C1_const + main::C1_read_free * main::C1_free_value;
    col witness D0_const;
    col witness D0_read_free;
    main::D0 = main::D0_const + main::D0_read_free * main::D0_free_value;
    col witness D1_const;
    col witness D1_read_free;
    main::D1 = main::D1_const + main::D1_read_free * main::D1_free_value;
    col fixed first_step = [1] + [0]*;
    col witness pc_update;
    main::pc_update = main::instr__jump_to_operation * main::_operation_id + main::instr__loop * main::pc + (1 - (main::instr__jump_to_operation + main::instr__loop)) * (main::pc + 1);
    main::pc' = (1 - main::first_step') * main::pc_update;
    main::t_0_0' = main::reg_write_C0_t_0_0 * main::C0 + (1 - (main::reg_write_C0_t_0_0 + main::instr__reset)) * main::t_0_0;
    main::t_0_1' = main::reg_write_C1_t_0_1 * main::C1 + (1 - (main::reg_write_C1_t_0_1 + main::instr__reset)) * main::t_0_1;
    main::t_1_0' = main::reg_write_D0_t_1_0 * main::D0 + (1 - (main::reg_write_D0_t_1_0 + main::instr__reset)) * main::t_1_0;
    main::t_1_1' = main::reg_write_D1_t_1_1 * main::D1 + (1 - (main::reg_write_D1_t_1_1 + main::instr__reset)) * main::t_1_1;
    col witness C0_free_value;
    col witness C1_free_value;
    col witness D0_free_value;
    col witness D1_free_value;
    [main::pc, main::reg_write_C0_t_0_0, main::reg_write_C1_t_0_1, main::reg_write_D0_t_1_0, main::reg_write_D1_t_1_1, main::instr_mul, main::instr_div, main::instr_assert_eq, main::instr__jump_to_operation, main::instr__reset, main::instr__loop, main::A0_const, main::read_A0_t_0_0, main::A1_const, main::read_A1_t_0_1, main::B0_const, main::read_B0_t_1_0, main::B1_const, main::read_B1_t_1_1, main::C0_const, main::C0_read_free, main::C1_const, main::C1_read_free, main::D0_const, main::D0_read_free, main::D1_const, main::D1_read_free] in [main__rom::p_line, main__rom::p_reg_write_C0_t_0_0, main__rom::p_reg_write_C1_t_0_1, main__rom::p_reg_write_D0_t_1_0, main__rom::p_reg_write_D1_t_1_1, main__rom::p_instr_mul, main__rom::p_instr_div, main__rom::p_instr_assert_eq, main__rom::p_instr__jump_to_operation, main__rom::p_instr__reset, main__rom::p_instr__loop, main__rom::p_A0_const, main__rom::p_read_A0_t_0_0, main__rom::p_A1_const, main__rom::p_read_A1_t_0_1, main__rom::p_B0_const, main__rom::p_read_B0_t_1_0, main__rom::p_B1_const, main__rom::p_read_B1_t_1_1, main__rom::p_C0_const, main__rom::p_C0_read_free, main__rom::p_C1_const, main__rom::p_C1_read_free, main__rom::p_D0_const, main__rom::p_D0_read_free, main__rom::p_D1_const, main__rom::p_D1_read_free];
    main::instr_div $ [1, main::A0, main::A1, main::B0, main::B1, main::C0, main::C1, main::D0, main::D1] is main_arith::CLK8[7] * main_arith::sel[0] $ [main_arith::operation_id, main_arith::y3c[0], main_arith::y3c[1], main_arith::x1c[0], main_arith::x1c[1], main_arith::y1c[0], main_arith::y1c[1], main_arith::x2c[0], main_arith::x2c[1]];
    main::instr_mul $ [0, main::A0, main::A1, main::B0, main::B1, main::C0, main::C1, main::D0, main::D1] is main_arith::CLK8[7] * main_arith::sel[1] $ [main_arith::operation_id, main_arith::x1c[0], main_arith::x1c[1], main_arith::y1c[0], main_arith::y1c[1], main_arith::y2c[0], main_arith::y2c[1], main_arith::y3c[0], main_arith::y3c[1]];
    col fixed _linker_first_step(i) { if i == 0 { 1 } else { 0 } };
    main::_linker_first_step * (main::_operation_id - 2) = 0;
namespace main__rom(65536);
    col fixed p_line = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] + [14]*;
    col fixed p_A0_const = [0, 0, 0, 0, 65535, 0, 0, 0, 65535, 0, 65535, 0, 4095, 0, 0] + [0]*;
    col fixed p_A1_const = [0, 0, 2, 0, 65535, 0, 7, 0, 65535, 0, 65534, 0, 65279, 0, 0] + [0]*;
    col fixed p_B0_const = [0, 0, 0, 0, 65535, 0, 0, 0, 15, 0, 0, 0, 15, 0, 0] + [0]*;
    col fixed p_B1_const = [0, 0, 3, 0, 65535, 0, 3, 0, 65535, 0, 255, 0, 65535, 0, 0] + [0]*;
    col fixed p_C0_const = [0, 0, 0, 0, 0, 65535, 0, 0, 0, 0, 0, 257, 0, 0, 0] + [0]*;
    col fixed p_C0_read_free = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_C1_const = [0, 0, 0, 0, 0, 65534, 0, 2, 0, 4096, 0, 256, 0, 255, 0] + [0]*;
    col fixed p_C1_read_free = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_D0_const = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0] + [0]*;
    col fixed p_D0_read_free = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_D1_const = [0, 0, 0, 6, 0, 1, 0, 1, 0, 4095, 0, 254, 0, 65534, 0] + [0]*;
    col fixed p_D1_read_free = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_instr__jump_to_operation = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_instr__loop = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] + [1]*;
    col fixed p_instr__reset = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_instr_assert_eq = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0] + [0]*;
    col fixed p_instr_div = [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_instr_mul = [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_read_A0_t_0_0 = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0] + [0]*;
    col fixed p_read_A1_t_0_1 = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0] + [0]*;
    col fixed p_read_B0_t_1_0 = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0] + [0]*;
    col fixed p_read_B1_t_1_1 = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0] + [0]*;
    col fixed p_reg_write_C0_t_0_0 = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_reg_write_C1_t_0_1 = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_reg_write_D0_t_1_0 = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_reg_write_D1_t_1_1 = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
namespace main_arith(65536);
    col witness operation_id;
    main_arith::operation_id * (1 - main_arith::operation_id) = 0;
    (1 - main_arith::operation_id) * main_arith::x2_0 = 0;
    (1 - main_arith::operation_id) * main_arith::x2_1 = 0;
    (1 - main_arith::operation_id) * main_arith::x2_2 = 0;
    (1 - main_arith::operation_id) * main_arith::x2_3 = 0;
    main_arith::operation_id * main_arith::y2[0] = 0;
    main_arith::operation_id * main_arith::y2[1] = 0;
    main_arith::operation_id * main_arith::y2[2] = 0;
    main_arith::operation_id * main_arith::y2[3] = 0;
    let quotient_hint: int -> std::prelude::Query = query |limb| match std::prover::eval(main_arith::operation_id) {
        1 => {
            let y3: int = main_arith::y3_int();
            let x1: int = main_arith::x1_int();
            let quotient: int = y3 / x1;
            std::prelude::Query::Hint(std::convert::fe::<int>(main_arith::select_limb(quotient, limb)))
        },
        _ => std::prelude::Query::None,
    };
    col witness y1_0;
    std::prelude::set_hint(main_arith::y1_0, query |i| main_arith::quotient_hint(0));
    col witness y1_1;
    std::prelude::set_hint(main_arith::y1_1, query |i| main_arith::quotient_hint(1));
    col witness y1_2;
    std::prelude::set_hint(main_arith::y1_2, query |i| main_arith::quotient_hint(2));
    col witness y1_3;
    std::prelude::set_hint(main_arith::y1_3, query |i| main_arith::quotient_hint(3));
    let remainder_hint: int -> std::prelude::Query = query |limb| match std::prover::eval(main_arith::operation_id) {
        1 => {
            let y3: int = main_arith::y3_int();
            let x1: int = main_arith::x1_int();
            let remainder: int = y3 % x1;
            std::prelude::Query::Hint(std::convert::fe::<int>(main_arith::select_limb(remainder, limb)))
        },
        _ => std::prelude::Query::None,
    };
    col witness x2_0;
    std::prelude::set_hint(main_arith::x2_0, query |i| main_arith::remainder_hint(0));
    col witness x2_1;
    std::prelude::set_hint(main_arith::x2_1, query |i| main_arith::remainder_hint(1));
    col witness x2_2;
    std::prelude::set_hint(main_arith::x2_2, query |i| main_arith::remainder_hint(2));
    col witness x2_3;
    std::prelude::set_hint(main_arith::x2_3, query |i| main_arith::remainder_hint(3));
    col witness x1[4];
    col witness y2[4];
    col witness y3[4];
    let select_limb: int, int -> int = |x, i| if i >= 0 { x >> 24 - i * 8 & 255 } else { 0 };
    let limbs_to_int: expr[] -> int = query |limbs| std::array::sum::<int>(std::array::map_enumerated::<expr, int>(limbs, |i, limb| std::convert::int::<fe>(std::prover::eval(limb)) << 24 - i * 8));
    let x1_int: -> int = query || main_arith::limbs_to_int(main_arith::x1);
    let y3_int: -> int = query || main_arith::limbs_to_int(main_arith::y3);
    col x1c[2] = [main_arith::x1[1] + main_arith::x1[0] * 256, main_arith::x1[3] + main_arith::x1[2] * 256];
    col y1c[2] = [main_arith::y1_1 + main_arith::y1_0 * 256, main_arith::y1_3 + main_arith::y1_2 * 256];
    col x2c[2] = [main_arith::x2_1 + main_arith::x2_0 * 256, main_arith::x2_3 + main_arith::x2_2 * 256];
    col y2c[2] = [main_arith::y2[1] + main_arith::y2[0] * 256, main_arith::y2[3] + main_arith::y2[2] * 256];
    col y3c[2] = [main_arith::y3[1] + main_arith::y3[0] * 256, main_arith::y3[3] + main_arith::y3[2] * 256];
    let CLK8: col[8] = std::array::new::<(int -> fe)>(8, |i| (|row| if row % 8 == i { 1 } else { 0 }));
    (main_arith::x1[0]' - main_arith::x1[0]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::x1[1]' - main_arith::x1[1]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::x1[2]' - main_arith::x1[2]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::x1[3]' - main_arith::x1[3]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y1_0' - main_arith::y1_0) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y1_1' - main_arith::y1_1) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y1_2' - main_arith::y1_2) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y1_3' - main_arith::y1_3) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::x2_0' - main_arith::x2_0) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::x2_1' - main_arith::x2_1) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::x2_2' - main_arith::x2_2) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::x2_3' - main_arith::x2_3) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y2[0]' - main_arith::y2[0]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y2[1]' - main_arith::y2[1]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y2[2]' - main_arith::y2[2]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y2[3]' - main_arith::y2[3]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y3[0]' - main_arith::y3[0]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y3[1]' - main_arith::y3[1]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y3[2]' - main_arith::y3[2]) * (1 - main_arith::CLK8[7]) = 0;
    (main_arith::y3[3]' - main_arith::y3[3]) * (1 - main_arith::CLK8[7]) = 0;
    col witness carry_low;
    col witness carry_high;
    (main_arith::carry_high * 256 + main_arith::carry_low) * main_arith::CLK8[0] = 0;
    col eq0_sum = (main_arith::x1[0] * main_arith::y1_0 + main_arith::x2_0 - main_arith::y3[0]) * main_arith::CLK8[0] + (main_arith::x1[0] * main_arith::y1_1 + main_arith::x1[1] * main_arith::y1_0 + main_arith::x2_1 - main_arith::y3[1]) * main_arith::CLK8[1] + (main_arith::x1[0] * main_arith::y1_2 + main_arith::x1[1] * main_arith::y1_1 + main_arith::x1[2] * main_arith::y1_0 + main_arith::x2_2 - main_arith::y3[2]) * main_arith::CLK8[2] + (main_arith::x1[0] * main_arith::y1_3 + main_arith::x1[1] * main_arith::y1_2 + main_arith::x1[2] * main_arith::y1_1 + main_arith::x1[3] * main_arith::y1_0 + main_arith::x2_3 - main_arith::y3[3]) * main_arith::CLK8[3] + (main_arith::x1[1] * main_arith::y1_3 + main_arith::x1[2] * main_arith::y1_2 + main_arith::x1[3] * main_arith::y1_1 - main_arith::y2[0]) * main_arith::CLK8[4] + (main_arith::x1[2] * main_arith::y1_3 + main_arith::x1[3] * main_arith::y1_2 - main_arith::y2[1]) * main_arith::CLK8[5] + (main_arith::x1[3] * main_arith::y1_3 - main_arith::y2[2]) * main_arith::CLK8[6] + (0 - main_arith::y2[3]) * main_arith::CLK8[7];
    main_arith::eq0_sum + (main_arith::carry_high * 256 + main_arith::carry_low) = (main_arith::carry_high' * 256 + main_arith::carry_low') * 256;
    col witness sel[2];
    main_arith::sel[0] * (1 - main_arith::sel[0]) = 0;
    main_arith::sel[1] * (1 - main_arith::sel[1]) = 0;
    [main_arith::x1[0] * main_arith::CLK8[0] + main_arith::x1[1] * main_arith::CLK8[1] + main_arith::x1[2] * main_arith::CLK8[2] + main_arith::x1[3] * main_arith::CLK8[3] + (main_arith::y1_0 * main_arith::CLK8[4] + main_arith::y1_1 * main_arith::CLK8[5] + main_arith::y1_2 * main_arith::CLK8[6] + main_arith::y1_3 * main_arith::CLK8[7])] in [main_arith_byte::BYTE];
    [main_arith::x2_0 * main_arith::CLK8[0] + main_arith::x2_1 * main_arith::CLK8[1] + main_arith::x2_2 * main_arith::CLK8[2] + main_arith::x2_3 * main_arith::CLK8[3] + (main_arith::y2[0] * main_arith::CLK8[4] + main_arith::y2[1] * main_arith::CLK8[5] + main_arith::y2[2] * main_arith::CLK8[6] + main_arith::y2[3] * main_arith::CLK8[7])] in [main_arith_byte::BYTE];
    [main_arith::y3[0] * main_arith::CLK8[0] + main_arith::y3[1] * main_arith::CLK8[1] + main_arith::y3[2] * main_arith::CLK8[2] + main_arith::y3[3] * main_arith::CLK8[3]] in [main_arith_byte::BYTE];
    [main_arith::carry_low] in [main_arith_byte::BYTE];
    [main_arith::carry_high] in [main_arith_byte::BYTE];
namespace main_arith_byte(65536);
    col fixed BYTE(i) { i & 255 };
