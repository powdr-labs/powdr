namespace std::array;
    enum Slice<T> {
        S(T[], int, int),
    }
    let<T> find_index: T[], (T -> bool) -> std::prelude::Option<int> = |arr, f| std::array::find_map_enumerated::<T, int>(arr, |i, x| if f(x) { std::prelude::Option::Some::<int>(i) } else { std::prelude::Option::None::<int> });
    let<T1, T2> find_map: T1[], (T1 -> std::prelude::Option<T2>) -> std::prelude::Option<T2> = |arr, f| std::array::find_map_enumerated::<T1, T2>(arr, |_, x| f(x));
    let<T1, T2> find_map_enumerated: T1[], (int, T1 -> std::prelude::Option<T2>) -> std::prelude::Option<T2> = |arr, f| std::array::find_internal::find_map_enumerated::<T1, T2>(arr, 0, std::array::len::<T1>(arr), f);
    let<T1, T2> fold: T1[], T2, (T2, T1 -> T2) -> T2 = |arr, initial, folder| std::utils::fold::<T1, T2>(std::array::len::<T1>(arr), |i| arr[i], initial, folder);
    let<T> len: T[] -> int = [];
    let<T1, T2> map: T1[], (T1 -> T2) -> T2[] = |arr, f| std::array::new::<T2>(std::array::len::<T1>(arr), |i| f(arr[i]));
    let<T1, T2> map_enumerated: T1[], (int, T1 -> T2) -> T2[] = |arr, f| std::array::new::<T2>(std::array::len::<T1>(arr), |i| f(i, arr[i]));
    let<T> new: int, (int -> T) -> T[] = |length, f| std::utils::fold::<T, T[]>(length, f, [], |acc, e| acc + [e]);
    let<T: FromLiteral + Mul> product: T[] -> T = |arr| std::array::fold::<T, T>(arr, 1, |a, b| a * b);
    let<T> set_element: T[], int, T -> T[] = |arr, i, x| {
        let _: () = std::check::assert(i < std::array::len::<T>(arr), || "Index out of bounds");
        std::array::map_enumerated::<T, T>(arr, |j, y| if i == j { x } else { y })
    };
    let<T> slice_pop: std::array::Slice<T> -> (std::array::Slice<T>, std::prelude::Option<T>) = |s| match s {
        std::array::Slice::S(_, _, 0) => (s, std::prelude::Option::None::<T>),
        std::array::Slice::S(arr, start, l) => (std::array::Slice::S::<T>(arr, start, l - 1), std::prelude::Option::Some::<T>(arr[start + l - 1])),
    };
    let<T> sort: T[], (T, T -> bool) -> T[] = |arr, lt| std::array::internal::sort::<T>(std::array::to_slice::<T>(arr), lt);
    let<T> split_slice_half: std::array::Slice<T> -> (std::array::Slice<T>, std::array::Slice<T>) = |s| match s {
        std::array::Slice::S(arr, start, l) => {
            let half_len: int = l / 2;
            (std::array::Slice::S::<T>(arr, start, half_len), std::array::Slice::S::<T>(arr, start + half_len, l - half_len))
        },
    };
    let<T> sub_array: T[], int, int -> T[] = |arr, start, l| std::array::new::<T>(l, |i| arr[start + i]);
    let<T: Add + FromLiteral> sum: T[] -> T = |arr| std::array::fold::<T, T>(arr, 0, |a, b| a + b);
    let<T> to_array: std::array::Slice<T> -> T[] = |s| match s {
        std::array::Slice::S(arr, start, l) => if start == 0 && l == std::array::len::<T>(arr) { arr } else { std::array::new::<T>(l, |i| arr[start + i]) },
    };
    let<T> to_slice: T[] -> std::array::Slice<T> = |x| std::array::Slice::S::<T>(x, 0, std::array::len::<T>(x));
    let<T1, T2, T3> zip: T1[], T2[], (T1, T2 -> T3) -> T3[] = |array1, array2, fn| std::array::new::<T3>(std::array::len::<T1>(array1), |i| fn(array1[i], array2[i]));
namespace std::array::find_internal;
    let<T1, T2> find_map_enumerated: T1[], int, int, (int, T1 -> std::prelude::Option<T2>) -> std::prelude::Option<T2> = |arr, i, l, f| if i >= l { std::prelude::Option::None::<T2> } else { match f(i, arr[i]) {
        std::prelude::Option::Some(x) => std::prelude::Option::Some::<T2>(x),
        std::prelude::Option::None => std::array::find_internal::find_map_enumerated::<T1, T2>(arr, i + 1, l, f),
    } };
namespace std::array::internal;
    let<T> merge: std::array::Slice<T>, std::array::Slice<T>, (T, T -> bool) -> T[] = |left, right, lt| match (std::array::slice_pop::<T>(left), std::array::slice_pop::<T>(right)) {
        ((_, std::prelude::Option::None), _) => std::array::to_array::<T>(right),
        (_, (_, std::prelude::Option::None)) => std::array::to_array::<T>(left),
        ((l_short, std::prelude::Option::Some(l_last)), (r_short, std::prelude::Option::Some(r_last))) => if lt(l_last, r_last) { std::array::internal::merge::<T>(left, r_short, lt) + [r_last] } else { std::array::internal::merge::<T>(l_short, right, lt) + [l_last] },
    };
    let<T> sort: std::array::Slice<T>, (T, T -> bool) -> T[] = |slice, lt| match slice {
        std::array::Slice::S(_, _, 0) => [],
        std::array::Slice::S(_, _, 1) => std::array::to_array::<T>(slice),
        s => {
            let (left, right): (std::array::Slice<T>, std::array::Slice<T>) = std::array::split_slice_half::<T>(s);
            let left_sorted: std::array::Slice<T> = std::array::to_slice::<T>(std::array::internal::sort::<T>(left, lt));
            let right_sorted: std::array::Slice<T> = std::array::to_slice::<T>(std::array::internal::sort::<T>(right, lt));
            std::array::internal::merge::<T>(left_sorted, right_sorted, lt)
        },
    };
namespace std::btree;
    enum BTree<K, V> {
        Inner((K, V)[], std::btree::BTree<K, V>[]),
        Leaf((K, V)[]),
    }
    enum CmpResult {
        Less,
        Equal,
        Greater,
    }
    let<K, V> get: std::btree::BTree<K, V>, K, (K, K -> std::btree::CmpResult) -> std::prelude::Option<V> = std::btree::internal::get::<K, V>;
    let<K, V> insert: std::btree::BTree<K, V>, (K, V), (K, K -> std::btree::CmpResult) -> std::btree::BTree<K, V> = |b_tree, (k, v), cmp| match std::btree::internal::insert::<K, V>(b_tree, (k, v), cmp) {
        std::btree::internal::InsertResult::Split(item, left, right) => std::btree::BTree::Inner::<K, V>([item], [left, right]),
        std::btree::internal::InsertResult::Updated(t) => t,
    };
    let max_items: int = 5;
    let<K, V> new: -> std::btree::BTree<K, V> = || std::btree::BTree::Leaf::<K, V>([]);
namespace std::btree::internal;
    enum InsertResult<K, V> {
        Split((K, V), std::btree::BTree<K, V>, std::btree::BTree<K, V>),
        Updated(std::btree::BTree<K, V>),
    }
    enum NodeSearchResult {
        InNode(int),
        InChild(int),
    }
    let<T> array_insert_at: T[], int, T -> T[] = |arr, i, x| {
        let (left, right): (T[], T[]) = std::btree::internal::array_split::<T>(arr, i);
        left + [x] + right
    };
    let<T> array_split: T[], int -> (T[], T[]) = |arr, l| {
        let left: T[] = std::array::sub_array::<T>(arr, 0, l);
        let right: T[] = std::array::sub_array::<T>(arr, l, std::array::len::<T>(arr) - l);
        (left, right)
    };
    let<T> array_split_pivot: T[], int -> (T[], T, T[]) = |arr, i| {
        let left: T[] = std::array::sub_array::<T>(arr, 0, i);
        let right: T[] = std::array::sub_array::<T>(arr, i + 1, std::array::len::<T>(arr) - i - 1);
        (left, arr[i], right)
    };
    let<K, V> get: std::btree::BTree<K, V>, K, (K, K -> std::btree::CmpResult) -> std::prelude::Option<V> = |b_tree, k, cmp| match b_tree {
        std::btree::BTree::Inner(items, children) => match std::btree::internal::search_in_node::<K, V, K>(items, k, cmp) {
            std::btree::internal::NodeSearchResult::InNode(i) => std::prelude::Option::Some::<V>(std::btree::internal::value_of_item::<K, V>(items[i])),
            std::btree::internal::NodeSearchResult::InChild(i) => std::btree::internal::get::<K, V>(children[i], k, cmp),
        },
        std::btree::BTree::Leaf(items) => std::array::find_map::<(K, V), V>(items, |(key, value)| match cmp(k, key) {
            std::btree::CmpResult::Equal => std::prelude::Option::Some::<V>(value),
            _ => std::prelude::Option::None::<V>,
        }),
    };
    let<K, V> insert: std::btree::BTree<K, V>, (K, V), (K, K -> std::btree::CmpResult) -> std::btree::internal::InsertResult<K, V> = |b_tree, (k, v), cmp| match b_tree {
        std::btree::BTree::Leaf(items) => std::btree::internal::insert_into_leaf::<K, V>(items, (k, v), cmp),
        std::btree::BTree::Inner(items, children) => match std::btree::internal::search_in_node::<K, V, K>(items, k, cmp) {
            std::btree::internal::NodeSearchResult::InNode(i) => std::btree::internal::InsertResult::Updated::<K, V>(std::btree::BTree::Inner::<K, V>(std::array::set_element::<(K, V)>(items, i, (k, v)), children)),
            std::btree::internal::NodeSearchResult::InChild(i) => match std::btree::internal::insert::<K, V>(children[i], (k, v), cmp) {
                std::btree::internal::InsertResult::Updated(child) => std::btree::internal::InsertResult::Updated::<K, V>(std::btree::BTree::Inner::<K, V>(items, std::array::set_element::<(std::btree::BTree<K, V>)>(children, i, child))),
                std::btree::internal::InsertResult::Split((k1, v1), left, right) => std::btree::internal::insert_into_inner::<K, V>(items, children, (k1, v1), i, left, right),
            },
        },
    };
    let<K, V> insert_into_inner: (K, V)[], std::btree::BTree<K, V>[], (K, V), int, std::btree::BTree<K, V>, std::btree::BTree<K, V> -> std::btree::internal::InsertResult<K, V> = |items, children, (k, v), i, left, right| {
        let new_items: (K, V)[] = std::btree::internal::array_insert_at::<(K, V)>(items, i, (k, v));
        let (children_left, _, children_right): (std::btree::BTree<K, V>[], std::btree::BTree<K, V>, std::btree::BTree<K, V>[]) = std::btree::internal::array_split_pivot::<(std::btree::BTree<K, V>)>(children, i);
        let new_children: std::btree::BTree<K, V>[] = children_left + [left, right] + children_right;
        if std::array::len::<(K, V)>(new_items) <= std::btree::max_items { std::btree::internal::InsertResult::Updated::<K, V>(std::btree::BTree::Inner::<K, V>(new_items, new_children)) } else { std::btree::internal::split_inner::<K, V>(new_items, new_children) }
    };
    let<K, V> insert_into_leaf: (K, V)[], (K, V), (K, K -> std::btree::CmpResult) -> std::btree::internal::InsertResult<K, V> = |items, (k, v), cmp| {
        let new_items: (K, V)[] = std::btree::internal::items_insert::<K, V>(items, (k, v), cmp);
        if std::array::len::<(K, V)>(new_items) <= std::btree::max_items { std::btree::internal::InsertResult::Updated::<K, V>(std::btree::BTree::Leaf::<K, V>(new_items)) } else { std::btree::internal::split_leaf::<K, V>(new_items) }
    };
    let<K, V> items_insert: (K, V)[], (K, V), (K, K -> std::btree::CmpResult) -> (K, V)[] = |items, (k, v), cmp| {
        let (new_items, ins): ((K, V)[], bool) = std::array::fold::<(K, V), ((K, V)[], bool)>(items, ([], std::prelude::false), |(acc, inserted), (key, value)| if inserted { (acc + [(key, value)], inserted) } else { match cmp(k, key) {
            std::btree::CmpResult::Less => (acc + [(k, v), (key, value)], std::prelude::true),
            std::btree::CmpResult::Equal => (acc + [(k, v)], std::prelude::true),
            std::btree::CmpResult::Greater => (acc + [(key, value)], std::prelude::false),
        } });
        if ins { new_items } else { new_items + [(k, v)] }
    };
    let one: int = 1;
    let<K1, V, K2> search_in_node: (K1, V)[], K2, (K2, K1 -> std::btree::CmpResult) -> std::btree::internal::NodeSearchResult = |items, k, cmp| {
        let r: std::prelude::Option<std::btree::internal::NodeSearchResult> = std::array::find_map_enumerated::<(K1, V), std::btree::internal::NodeSearchResult>(items, |i, (key, _)| match cmp(k, key) {
            std::btree::CmpResult::Less => std::prelude::Option::Some::<std::btree::internal::NodeSearchResult>(std::btree::internal::NodeSearchResult::InChild(i)),
            std::btree::CmpResult::Equal => std::prelude::Option::Some::<std::btree::internal::NodeSearchResult>(std::btree::internal::NodeSearchResult::InNode(i)),
            std::btree::CmpResult::Greater => std::prelude::Option::None::<std::btree::internal::NodeSearchResult>,
        });
        std::utils::unwrap_or_else::<std::btree::internal::NodeSearchResult>(r, || std::btree::internal::NodeSearchResult::InChild(std::array::len::<(K1, V)>(items)))
    };
    let<K, V> split_inner: (K, V)[], std::btree::BTree<K, V>[] -> std::btree::internal::InsertResult<K, V> = |items, children| {
        let split: int = (std::array::len::<(K, V)>(items) - 1) / 2;
        let (left_items, push_up, right_items): ((K, V)[], (K, V), (K, V)[]) = std::btree::internal::array_split_pivot::<(K, V)>(items, split);
        let (left_children, right_children): (std::btree::BTree<K, V>[], std::btree::BTree<K, V>[]) = std::btree::internal::array_split::<(std::btree::BTree<K, V>)>(children, split + 1);
        std::btree::internal::InsertResult::Split::<K, V>(push_up, std::btree::BTree::Inner::<K, V>(left_items, left_children), std::btree::BTree::Inner::<K, V>(right_items, right_children))
    };
    let<K, V> split_leaf: (K, V)[] -> std::btree::internal::InsertResult<K, V> = |items| {
        let split: int = (std::array::len::<(K, V)>(items) - 1) / 2;
        let (left, center, right): ((K, V)[], (K, V), (K, V)[]) = std::btree::internal::array_split_pivot::<(K, V)>(items, split);
        std::btree::internal::InsertResult::Split::<K, V>(center, std::btree::BTree::Leaf::<K, V>(left), std::btree::BTree::Leaf::<K, V>(right))
    };
    let<K, V> value_of_item: (K, V) -> V = |(_, value)| value;
namespace std::check;
    let assert: bool, (-> string) -> () = |condition, reason| if !condition { std::check::panic(reason()) } else { () };
    let panic: string -> ! = [];
namespace std::constraints;
    let make_conditional: std::prelude::Constr, expr -> std::prelude::Constr = |constraint, condition| match constraint {
        std::prelude::Constr::Identity(l, r) => condition * (l - r) = 0,
        std::prelude::Constr::Lookup((std::prelude::Option::None, sel_r), exprs) => std::prelude::Constr::Lookup((std::prelude::Option::Some::<expr>(condition), sel_r), exprs),
        std::prelude::Constr::Lookup((std::prelude::Option::Some(sel_l), sel_r), exprs) => std::prelude::Constr::Lookup((std::prelude::Option::Some::<expr>(sel_l * condition), sel_r), exprs),
        std::prelude::Constr::Permutation((std::prelude::Option::None, sel_r), exprs) => std::prelude::Constr::Permutation((std::prelude::Option::Some::<expr>(condition), sel_r), exprs),
        std::prelude::Constr::Permutation((std::prelude::Option::Some(sel_l), sel_r), exprs) => std::prelude::Constr::Permutation((std::prelude::Option::Some::<expr>(sel_l * condition), sel_r), exprs),
        std::prelude::Constr::Connection(_) => std::check::panic("Connection constraints cannot be conditional"),
    };
namespace std::convert;
    let expr = [];
    let fe = [];
    let int = [];
namespace std::debug;
    let<T: ToString> print: T -> () = [];
    let<T: ToString> println: T -> () = |msg| {
        let _: () = std::debug::print::<T>(msg);
        std::debug::print::<string>("\n")
    };
namespace std::field;
    let BABYBEAR_PRIME: int = 2013265921;
    let BN254_PRIME: int = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    let GOLDILOCKS_PRIME: int = 18446744069414584321;
    enum KnownField {
        Goldilocks,
        BN254,
        BabyBear,
    }
    let known_field: -> std::prelude::Option<std::field::KnownField> = || if std::field::modulus() == std::field::GOLDILOCKS_PRIME { std::prelude::Option::Some::<std::field::KnownField>(std::field::KnownField::Goldilocks) } else { if std::field::modulus() == std::field::BN254_PRIME { std::prelude::Option::Some::<std::field::KnownField>(std::field::KnownField::BN254) } else { if std::field::modulus() == std::field::BABYBEAR_PRIME { std::prelude::Option::Some::<std::field::KnownField>(std::field::KnownField::BabyBear) } else { std::prelude::Option::None::<std::field::KnownField> } } };
    let modulus: -> int = [];
    let require_known_field: std::field::KnownField, (-> string) -> () = |f, err| match (f, std::field::known_field()) {
        (std::field::KnownField::Goldilocks, std::prelude::Option::Some(std::field::KnownField::Goldilocks)) => (),
        (std::field::KnownField::BN254, std::prelude::Option::Some(std::field::KnownField::BN254)) => (),
        (std::field::KnownField::BabyBear, std::prelude::Option::Some(std::field::KnownField::BabyBear)) => (),
        _ => std::check::panic(err()),
    };
namespace std::math::ff;
    let add: int, int, int -> int = |x, y, modulus| std::math::ff::reduce(x + y, modulus);
    let div: int, int, int -> int = |x, y, modulus| std::math::ff::mul(x, std::math::ff::inverse(y, modulus), modulus);
    let extended_gcd: int, int -> (int, int) = |a, b| if b == 0 { if a == 1 { (1, 0) } else { std::check::panic("Inputs are not co-prime, inverse does not exist.") } } else {
        let (r1, r2): (int, int) = std::math::ff::extended_gcd(b, a % b);
        (r2, r1 - a / b * r2)
    };
    let inv_field: fe -> fe = |x| std::convert::fe::<int>(std::math::ff::inverse(std::convert::int::<fe>(x), std::field::modulus()));
    let inverse: int, int -> int = |x, modulus| if x <= 0 || x >= modulus { if x == 0 { std::check::panic("Tried to compute the inverse of zero.") } else { std::check::panic("Tried to compute the inverse of a negative number or a number outside the field.") } } else {
        let (r, _): (int, int) = std::math::ff::extended_gcd(x, modulus);
        std::math::ff::reduce(r, modulus)
    };
    let mul: int, int, int -> int = |x, y, modulus| std::math::ff::reduce(x * y, modulus);
    let reduce: int, int -> int = |x, modulus| if x < 0 { (modulus - -x % modulus) % modulus } else { x % modulus };
    let sub: int, int, int -> int = |x, y, modulus| std::math::ff::reduce(x - y, modulus);
namespace std::math::fp2;
    enum Fp2<T> {
        Fp2(T, T),
    }
    let<T: Add> add_ext: std::math::fp2::Fp2<T>, std::math::fp2::Fp2<T> -> std::math::fp2::Fp2<T> = |a, b| match (a, b) {
        (std::math::fp2::Fp2::Fp2(a0, a1), std::math::fp2::Fp2::Fp2(b0, b1)) => std::math::fp2::Fp2::Fp2::<T>(a0 + b0, a1 + b1),
    };
    let constrain_eq_ext: std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr> -> std::prelude::Constr[] = |a, b| match (a, b) {
        (std::math::fp2::Fp2::Fp2(a0, a1), std::math::fp2::Fp2::Fp2(b0, b1)) => [a0 = b0, a1 = b1],
    };
    let eq_ext: std::math::fp2::Fp2<fe>, std::math::fp2::Fp2<fe> -> bool = |a, b| match (a, b) {
        (std::math::fp2::Fp2::Fp2(a0, a1), std::math::fp2::Fp2::Fp2(b0, b1)) => a0 == b0 && a1 == b1,
    };
    let eval_ext: std::math::fp2::Fp2<expr> -> std::math::fp2::Fp2<fe> = query |a| match a {
        std::math::fp2::Fp2::Fp2(a0, a1) => std::math::fp2::Fp2::Fp2::<fe>(std::prover::eval(a0), std::prover::eval(a1)),
    };
    let expr_ext: std::math::fp2::Fp2<fe> -> std::math::fp2::Fp2<expr> = |a| match a {
        std::math::fp2::Fp2::Fp2(a0, a1) => std::math::fp2::Fp2::Fp2::<expr>(std::convert::expr::<fe>(a0), std::convert::expr::<fe>(a1)),
    };
    let fp2_from_array: expr[] -> std::math::fp2::Fp2<expr> = |arr| { if std::math::fp2::is_extension(arr) { std::math::fp2::Fp2::Fp2::<expr>(arr[0], arr[1]) } else {
        let _: () = std::check::assert(!std::math::fp2::needs_extension(), || "The field is too small and needs to move to the extension field. Pass two elements instead!");
        std::math::fp2::from_base::<expr>(arr[0])
    } };
    let<T: FromLiteral> from_base: T -> std::math::fp2::Fp2<T> = |x| std::math::fp2::Fp2::Fp2::<T>(x, 0);
    let inv_ext: std::math::fp2::Fp2<fe> -> std::math::fp2::Fp2<fe> = |a| match a {
        std::math::fp2::Fp2::Fp2(a0, a1) => {
            let factor: fe = std::math::ff::inv_field(7 * a1 * a1 - a0 * a0);
            std::math::fp2::Fp2::Fp2::<fe>(-a0 * factor, a1 * factor)
        },
    };
    let is_extension: expr[] -> bool = |arr| match std::array::len::<expr>(arr) {
        1 => std::prelude::false,
        2 => std::prelude::true,
        _ => std::check::panic("Expected 1 or 2 accumulator columns!"),
    };
    let<T: Add + FromLiteral + Mul> mul_ext: std::math::fp2::Fp2<T>, std::math::fp2::Fp2<T> -> std::math::fp2::Fp2<T> = |a, b| match (a, b) {
        (std::math::fp2::Fp2::Fp2(a0, a1), std::math::fp2::Fp2::Fp2(b0, b1)) => std::math::fp2::Fp2::Fp2::<T>(a0 * b0 + 7 * a1 * b1, a1 * b0 + a0 * b1),
    };
    let needs_extension: -> bool = || match std::field::known_field() {
        std::prelude::Option::Some(std::field::KnownField::Goldilocks) => std::prelude::true,
        std::prelude::Option::Some(std::field::KnownField::BN254) => std::prelude::false,
        None => std::check::panic("The permutation/lookup argument is not implemented for the current field!"),
    };
    let next_ext: std::math::fp2::Fp2<expr> -> std::math::fp2::Fp2<expr> = |a| match a {
        std::math::fp2::Fp2::Fp2(a0, a1) => std::math::fp2::Fp2::Fp2::<expr>(a0', a1'),
    };
    let<T: Sub> sub_ext: std::math::fp2::Fp2<T>, std::math::fp2::Fp2<T> -> std::math::fp2::Fp2<T> = |a, b| match (a, b) {
        (std::math::fp2::Fp2::Fp2(a0, a1), std::math::fp2::Fp2::Fp2(b0, b1)) => std::math::fp2::Fp2::Fp2::<T>(a0 - b0, a1 - b1),
    };
    let<T> unpack_ext: std::math::fp2::Fp2<T> -> (T, T) = |a| match a {
        std::math::fp2::Fp2::Fp2(a0, a1) => (a0, a1),
    };
    let<T> unpack_ext_array: std::math::fp2::Fp2<T> -> T[] = |a| match a {
        std::math::fp2::Fp2::Fp2(a0, a1) => [a0, a1],
    };
namespace std::math::fp2::test;
    let add: -> () = || {
        let test_add: std::math::fp2::Fp2<fe>, std::math::fp2::Fp2<fe>, std::math::fp2::Fp2<fe> -> () = |a, b, c| std::check::assert(std::math::fp2::eq_ext(std::math::fp2::add_ext::<fe>(a, b), c), || "Wrong addition result");
        let _: () = test_add(std::math::fp2::from_base::<fe>(0), std::math::fp2::from_base::<fe>(0), std::math::fp2::from_base::<fe>(0));
        let _: () = test_add(std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::from_base::<fe>(0), std::math::fp2::Fp2::Fp2::<fe>(123, 1234));
        let _: () = test_add(std::math::fp2::from_base::<fe>(0), std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::Fp2::Fp2::<fe>(123, 1234));
        let _: () = test_add(std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::Fp2::Fp2::<fe>(567, 5678), std::math::fp2::Fp2::Fp2::<fe>(690, 6912));
        test_add(std::math::fp2::Fp2::Fp2::<fe>(-1, -1), std::math::fp2::Fp2::Fp2::<fe>(3, 4), std::math::fp2::Fp2::Fp2::<fe>(2, 3))
    };
    let inverse: -> ()[] = || {
        let test_elements: std::math::fp2::Fp2<fe>[] = [std::math::fp2::from_base::<fe>(1), std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::Fp2::Fp2::<fe>(-1, 500)];
        std::array::map::<(std::math::fp2::Fp2<fe>), ()>(test_elements, |x| {
            let mul_with_inverse: std::math::fp2::Fp2<fe> = std::math::fp2::mul_ext::<fe>(x, std::math::fp2::inv_ext(x));
            std::check::assert(std::math::fp2::eq_ext(mul_with_inverse, std::math::fp2::from_base::<fe>(1)), || "Should be 1")
        })
    };
    let mul: -> () = || {
        let test_mul: std::math::fp2::Fp2<fe>, std::math::fp2::Fp2<fe>, std::math::fp2::Fp2<fe> -> () = |a, b, c| std::check::assert(std::math::fp2::eq_ext(std::math::fp2::mul_ext::<fe>(a, b), c), || "Wrong multiplication result");
        let _: () = test_mul(std::math::fp2::from_base::<fe>(1), std::math::fp2::from_base::<fe>(1), std::math::fp2::from_base::<fe>(1));
        let _: () = test_mul(std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::from_base::<fe>(1), std::math::fp2::Fp2::Fp2::<fe>(123, 1234));
        let _: () = test_mul(std::math::fp2::from_base::<fe>(1), std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::Fp2::Fp2::<fe>(123, 1234));
        let _: () = test_mul(std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::from_base::<fe>(0), std::math::fp2::from_base::<fe>(0));
        let _: () = test_mul(std::math::fp2::from_base::<fe>(0), std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::from_base::<fe>(0));
        let _: () = test_mul(std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::Fp2::Fp2::<fe>(567, 5678), std::math::fp2::Fp2::Fp2::<fe>(49116305, 1398072));
        test_mul(std::math::fp2::Fp2::Fp2::<fe>(-1, -2), std::math::fp2::Fp2::Fp2::<fe>(-3, 4), std::math::fp2::Fp2::Fp2::<fe>(3 - 7 * 8, 6 - 4))
    };
    let sub: -> () = || {
        let test_sub: std::math::fp2::Fp2<fe>, std::math::fp2::Fp2<fe>, std::math::fp2::Fp2<fe> -> () = |a, b, c| std::check::assert(std::math::fp2::eq_ext(std::math::fp2::sub_ext::<fe>(a, b), c), || "Wrong subtraction result");
        let _: () = test_sub(std::math::fp2::from_base::<fe>(0), std::math::fp2::from_base::<fe>(0), std::math::fp2::from_base::<fe>(0));
        let _: () = test_sub(std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::from_base::<fe>(0), std::math::fp2::Fp2::Fp2::<fe>(123, 1234));
        let _: () = test_sub(std::math::fp2::Fp2::Fp2::<fe>(123, 1234), std::math::fp2::Fp2::Fp2::<fe>(567, 5678), std::math::fp2::Fp2::Fp2::<fe>(123 - 567, 1234 - 5678));
        test_sub(std::math::fp2::Fp2::Fp2::<fe>(-1, -1), std::math::fp2::Fp2::Fp2::<fe>(4294967296, 1), std::math::fp2::Fp2::Fp2::<fe>(-4294967296 - 1, -2))
    };
namespace std::math::fp4;
    enum Fp4<T> {
        Fp4(T, T, T, T),
    }
    let<T: Add> add_ext: std::math::fp4::Fp4<T>, std::math::fp4::Fp4<T> -> std::math::fp4::Fp4<T> = |a, b| match (a, b) {
        (std::math::fp4::Fp4::Fp4(a0, a1, a2, a3), std::math::fp4::Fp4::Fp4(b0, b1, b2, b3)) => std::math::fp4::Fp4::Fp4::<T>(a0 + b0, a1 + b1, a2 + b2, a3 + b3),
    };
    let constrain_eq_ext: std::math::fp4::Fp4<expr>, std::math::fp4::Fp4<expr> -> std::prelude::Constr[] = |a, b| match (a, b) {
        (std::math::fp4::Fp4::Fp4(a0, a1, a2, a3), std::math::fp4::Fp4::Fp4(b0, b1, b2, b3)) => [a0 = b0, a1 = b1, a2 = b2, a3 = b3],
    };
    let eq_ext: std::math::fp4::Fp4<fe>, std::math::fp4::Fp4<fe> -> bool = |a, b| match (a, b) {
        (std::math::fp4::Fp4::Fp4(a0, a1, a2, a3), std::math::fp4::Fp4::Fp4(b0, b1, b2, b3)) => a0 == b0 && a1 == b1 && a2 == b2 && a3 == b3,
    };
    let eval_ext: std::math::fp4::Fp4<expr> -> std::math::fp4::Fp4<fe> = query |a| match a {
        std::math::fp4::Fp4::Fp4(a0, a1, a2, a3) => std::math::fp4::Fp4::Fp4::<fe>(std::prover::eval(a0), std::prover::eval(a1), std::prover::eval(a2), std::prover::eval(a3)),
    };
    let expr_ext: std::math::fp4::Fp4<fe> -> std::math::fp4::Fp4<expr> = |a| match a {
        std::math::fp4::Fp4::Fp4(a0, a1, a2, a3) => std::math::fp4::Fp4::Fp4::<expr>(std::convert::expr::<fe>(a0), std::convert::expr::<fe>(a1), std::convert::expr::<fe>(a2), std::convert::expr::<fe>(a3)),
    };
    let<T: FromLiteral> from_base: T -> std::math::fp4::Fp4<T> = |x| std::math::fp4::Fp4::Fp4::<T>(x, 0, 0, 0);
    let inv_ext: std::math::fp4::Fp4<fe> -> std::math::fp4::Fp4<fe> = |a| match a {
        std::math::fp4::Fp4::Fp4(a0, a1, a2, a3) => {
            let b0: fe = a0 * a0 - 11 * (a1 * (a3 + a3) - a2 * a2);
            let b2: fe = a0 * (a2 + a2) - a1 * a1 - 11 * (a3 * a3);
            let c: fe = b0 * b0 - 11 * b2 * b2;
            let ic: fe = std::math::ff::inv_field(c);
            let b_0: fe = b0 * ic;
            let b_2: fe = b2 * ic;
            std::math::fp4::Fp4::Fp4::<fe>(a0 * b_0 - 11 * a2 * b_2, -1 * a1 * b_0 + 11 * a3 * b_2, -1 * a0 * b_2 + a2 * b_0, a1 * b_2 - a3 * b_0)
        },
    };
    let<T: Add + FromLiteral + Mul> mul_ext: std::math::fp4::Fp4<T>, std::math::fp4::Fp4<T> -> std::math::fp4::Fp4<T> = |a, b| match (a, b) {
        (std::math::fp4::Fp4::Fp4(a0, a1, a2, a3), std::math::fp4::Fp4::Fp4(b0, b1, b2, b3)) => std::math::fp4::Fp4::Fp4::<T>(a0 * b0 + 11 * (a1 * b3 + a2 * b2 + a3 * b1), a0 * b1 + a1 * b0 + 11 * (a2 * b3 + a3 * b2), a0 * b2 + a1 * b1 + a2 * b0 + 11 * (a3 * b3), a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0),
    };
    let next_ext: std::math::fp4::Fp4<expr> -> std::math::fp4::Fp4<expr> = |a| match a {
        std::math::fp4::Fp4::Fp4(a0, a1, a2, a3) => std::math::fp4::Fp4::Fp4::<expr>(a0', a1', a2', a3'),
    };
    let<T: Sub> sub_ext: std::math::fp4::Fp4<T>, std::math::fp4::Fp4<T> -> std::math::fp4::Fp4<T> = |a, b| match (a, b) {
        (std::math::fp4::Fp4::Fp4(a0, a1, a2, a3), std::math::fp4::Fp4::Fp4(b0, b1, b2, b3)) => std::math::fp4::Fp4::Fp4::<T>(a0 - b0, a1 - b1, a2 - b2, a3 - b3),
    };
    let<T> unpack_ext: std::math::fp4::Fp4<T> -> (T, T, T, T) = |a| match a {
        std::math::fp4::Fp4::Fp4(a0, a1, a2, a3) => (a0, a1, a2, a3),
    };
    let<T> unpack_ext_array: std::math::fp4::Fp4<T> -> T[] = |a| match a {
        std::math::fp4::Fp4::Fp4(a0, a1, a2, a3) => [a0, a1, a2, a3],
    };
namespace std::math::fp4::test;
    let add: -> () = || {
        let test_add: std::math::fp4::Fp4<fe>, std::math::fp4::Fp4<fe>, std::math::fp4::Fp4<fe> -> () = |a, b, c| std::check::assert(std::math::fp4::eq_ext(std::math::fp4::add_ext::<fe>(a, b), c), || "Wrong addition result");
        let _: () = test_add(std::math::fp4::from_base::<fe>(0), std::math::fp4::from_base::<fe>(0), std::math::fp4::from_base::<fe>(0));
        let _: () = test_add(std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 1, 2), std::math::fp4::from_base::<fe>(0), std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 1, 2));
        let _: () = test_add(std::math::fp4::from_base::<fe>(0), std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 123, 1334), std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 123, 1334));
        let _: () = test_add(std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 123, 122), std::math::fp4::Fp4::Fp4::<fe>(567, 5678, 250, 678), std::math::fp4::Fp4::Fp4::<fe>(690, 6912, 373, 800));
        test_add(std::math::fp4::Fp4::Fp4::<fe>(-1, -1, -1, -1), std::math::fp4::Fp4::Fp4::<fe>(3, 4, 5, 6), std::math::fp4::Fp4::Fp4::<fe>(2, 3, 4, 5));
        test_add(std::math::fp4::Fp4::Fp4::<fe>(-11, -11, -11, -11), std::math::fp4::Fp4::Fp4::<fe>(0, 0, 0, 0), std::math::fp4::Fp4::Fp4::<fe>(-11, -11, -11, -11));
        test_add(std::math::fp4::Fp4::Fp4::<fe>(-1, 0, 0, 0), std::math::fp4::Fp4::Fp4::<fe>(1, 0, 0, 0), std::math::fp4::from_base::<fe>(0));
    };
    let inverse: -> ()[] = || {
        let test_elements: std::math::fp4::Fp4<fe>[] = [std::math::fp4::from_base::<fe>(1), std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 1, 2), std::math::fp4::Fp4::Fp4::<fe>(-1, 500, 3, 5)];
        std::array::map::<(std::math::fp4::Fp4<fe>), ()>(test_elements, |x| {
            let mul_with_inverse: std::math::fp4::Fp4<fe> = std::math::fp4::mul_ext::<fe>(x, std::math::fp4::inv_ext(x));
            std::check::assert(std::math::fp4::eq_ext(mul_with_inverse, std::math::fp4::from_base::<fe>(1)), || "Should be 1")
        })
    };
    let mul: -> () = || {
        let test_mul: std::math::fp4::Fp4<fe>, std::math::fp4::Fp4<fe>, std::math::fp4::Fp4<fe> -> () = |a, b, c| std::check::assert(std::math::fp4::eq_ext(std::math::fp4::mul_ext::<fe>(a, b), c), || "Wrong multiplication result");
        let _: () = test_mul(std::math::fp4::from_base::<fe>(1), std::math::fp4::from_base::<fe>(1), std::math::fp4::from_base::<fe>(1));
        let _: () = test_mul(std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 280, 400), std::math::fp4::from_base::<fe>(1), std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 280, 400));
        let _: () = test_mul(std::math::fp4::from_base::<fe>(1), std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 12, 15), std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 12, 15));
        let _: () = test_mul(std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 234, 500), std::math::fp4::from_base::<fe>(0), std::math::fp4::from_base::<fe>(0));
        let _: () = test_mul(std::math::fp4::from_base::<fe>(0), std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 33, 200), std::math::fp4::from_base::<fe>(0));
        test_mul(std::math::fp4::Fp4::Fp4::<fe>(1, 2, 3, 4), std::math::fp4::Fp4::Fp4::<fe>(5, 6, 7, 8), std::math::fp4::Fp4::Fp4::<fe>(676, 588, 386, 60));
        test_mul(std::math::fp4::Fp4::Fp4::<fe>(-1, -2, -3, -4), std::math::fp4::Fp4::Fp4::<fe>(-3, 4, 4, 5), std::math::fp4::Fp4::Fp4::<fe>(-415, -339, -223, -13));
    };
    let sub: -> () = || {
        let test_sub: std::math::fp4::Fp4<fe>, std::math::fp4::Fp4<fe>, std::math::fp4::Fp4<fe> -> () = |a, b, c| std::check::assert(std::math::fp4::eq_ext(std::math::fp4::sub_ext::<fe>(a, b), c), || "Wrong subtraction result");
        let _: () = test_sub(std::math::fp4::from_base::<fe>(0), std::math::fp4::from_base::<fe>(0), std::math::fp4::from_base::<fe>(0));
        let _: () = test_sub(std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 124, 1235), std::math::fp4::from_base::<fe>(0), std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 124, 1235));
        let _: () = test_sub(std::math::fp4::Fp4::Fp4::<fe>(123, 1234, 248, 5000), std::math::fp4::Fp4::Fp4::<fe>(567, 5678, 300, 2380), std::math::fp4::Fp4::Fp4::<fe>(123 - 567, 1234 - 5678, 248 - 300, 5000 - 2380));
        test_sub(std::math::fp4::Fp4::Fp4::<fe>(-1, -1, 0, 0), std::math::fp4::Fp4::Fp4::<fe>(2013265920, 1, 0, 0), std::math::fp4::Fp4::Fp4::<fe>(-2013265920 - 1, -2, 0, 0))
    };
namespace std::prelude;
    enum Constr {
        Identity(expr, expr),
        Lookup((std::prelude::Option<expr>, std::prelude::Option<expr>), (expr, expr)[]),
        Permutation((std::prelude::Option<expr>, std::prelude::Option<expr>), (expr, expr)[]),
        Connection((expr, expr)[]),
    }
    enum Option<T> {
        None,
        Some(T),
    }
    enum Query {
        Input(int),
        Output(int, int),
        Hint(fe),
        DataIdentifier(int, int),
        None,
    }
    enum SelectedExprs {
        SelectedExprs(expr, expr[]),
        JustExprs(expr[]),
    }
    let challenge: int, int -> expr = [];
    let false: bool = !std::prelude::true;
    let set_hint: expr, (int -> std::prelude::Query) -> () = [];
    let true: bool = "" == "";
namespace std::protocols::bus;
    let bus_interaction: expr, expr, expr[], expr, expr[], std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr> -> std::prelude::Constr[] = |is_first, id, tuple, multiplicity, acc, alpha, beta| {
        let folded: std::math::fp2::Fp2<expr> = std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint_with_id::<expr>(id, tuple, alpha));
        let folded_next: std::math::fp2::Fp2<expr> = std::math::fp2::next_ext(folded);
        let m_ext: std::math::fp2::Fp2<expr> = std::math::fp2::from_base::<expr>(multiplicity);
        let m_ext_next: std::math::fp2::Fp2<expr> = std::math::fp2::next_ext(m_ext);
        let acc_ext: std::math::fp2::Fp2<expr> = std::math::fp2::fp2_from_array(acc);
        let next_acc: std::math::fp2::Fp2<expr> = std::math::fp2::next_ext(acc_ext);
        let is_first_next: std::math::fp2::Fp2<expr> = std::math::fp2::from_base::<expr>(is_first');
        let update_expr: std::math::fp2::Fp2<expr> = std::math::fp2::sub_ext::<expr>(std::math::fp2::mul_ext::<expr>(folded_next, std::math::fp2::sub_ext::<expr>(next_acc, std::math::fp2::mul_ext::<expr>(acc_ext, std::math::fp2::sub_ext::<expr>(std::math::fp2::from_base::<expr>(1), is_first_next)))), m_ext_next);
        std::math::fp2::constrain_eq_ext(update_expr, std::math::fp2::from_base::<expr>(0))
    };
    let bus_receive: expr, expr, expr[], expr, expr[], std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr> -> std::prelude::Constr[] = |is_first, id, tuple, multiplicity, acc, alpha, beta| { std::protocols::bus::bus_interaction(is_first, id, tuple, -1 * multiplicity, acc, alpha, beta) };
    let bus_send: expr, expr, expr[], expr, expr[], std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr> -> std::prelude::Constr[] = |is_first, id, tuple, multiplicity, acc, alpha, beta| { std::protocols::bus::bus_interaction(is_first, id, tuple, multiplicity, acc, alpha, beta) };
    let compute_next_z_receive: expr, expr, expr[], expr, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr> -> fe[] = query |is_first, id, tuple, multiplicity, acc, alpha, beta| std::protocols::bus::compute_next_z_send(is_first, id, tuple, -multiplicity, acc, alpha, beta);
    let compute_next_z_send: expr, expr, expr[], expr, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr> -> fe[] = query |is_first, id, tuple, multiplicity, acc, alpha, beta| {
        let folded: std::math::fp2::Fp2<expr> = std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint_with_id::<expr>(id, tuple, alpha));
        let folded_next: std::math::fp2::Fp2<expr> = std::math::fp2::next_ext(folded);
        let m_ext: std::math::fp2::Fp2<expr> = std::math::fp2::from_base::<expr>(multiplicity);
        let m_ext_next: std::math::fp2::Fp2<expr> = std::math::fp2::next_ext(m_ext);
        let is_first_next: fe = std::prover::eval(is_first');
        let current_acc: std::math::fp2::Fp2<fe> = if is_first_next == 1 { std::math::fp2::from_base::<fe>(0) } else { std::math::fp2::eval_ext(acc) };
        let res: std::math::fp2::Fp2<fe> = std::math::fp2::add_ext::<fe>(current_acc, std::math::fp2::mul_ext::<fe>(std::math::fp2::eval_ext(m_ext_next), std::math::fp2::inv_ext(std::math::fp2::eval_ext(folded_next))));
        std::math::fp2::unpack_ext_array::<fe>(res)
    };
namespace std::protocols::fingerprint;
    let<T: Add + FromLiteral + Mul> fingerprint: T[], std::math::fp2::Fp2<T> -> std::math::fp2::Fp2<T> = |expr_array, alpha| std::array::fold::<T, (std::math::fp2::Fp2<T>)>(expr_array, std::math::fp2::from_base::<T>(0), |sum_acc, el| std::math::fp2::add_ext::<T>(std::math::fp2::mul_ext::<T>(alpha, sum_acc), std::math::fp2::from_base::<T>(el)));
    let<T: Add + FromLiteral + Mul> fingerprint_with_id: T, T[], std::math::fp2::Fp2<T> -> std::math::fp2::Fp2<T> = |id, expr_array, alpha| std::protocols::fingerprint::fingerprint::<T>([id] + expr_array, alpha);
namespace std::protocols::lookup;
    let compute_next_z: std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr, expr -> fe[] = query |acc, alpha, beta, lookup_constraint, multiplicities| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::lookup::unpack_lookup_constraint(lookup_constraint);
        let lhs_denom: std::math::fp2::Fp2<expr> = std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint::<expr>(lhs, alpha));
        let rhs_denom: std::math::fp2::Fp2<expr> = std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint::<expr>(rhs, alpha));
        let m_ext: std::math::fp2::Fp2<expr> = std::math::fp2::from_base::<expr>(multiplicities);
        let res: std::math::fp2::Fp2<fe> = std::math::fp2::add_ext::<fe>(std::math::fp2::eval_ext(acc), std::math::fp2::sub_ext::<fe>(std::math::fp2::mul_ext::<fe>(std::math::fp2::inv_ext(std::math::fp2::eval_ext(lhs_denom)), std::math::fp2::eval_ext(std::math::fp2::from_base::<expr>(lhs_selector))), std::math::fp2::mul_ext::<fe>(std::math::fp2::mul_ext::<fe>(std::math::fp2::eval_ext(m_ext), std::math::fp2::inv_ext(std::math::fp2::eval_ext(rhs_denom))), std::math::fp2::eval_ext(std::math::fp2::from_base::<expr>(rhs_selector)))));
        std::math::fp2::unpack_ext_array::<fe>(res)
    };
    let lookup: expr, expr[], std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr, expr -> std::prelude::Constr[] = |is_first, acc, alpha, beta, lookup_constraint, multiplicities| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::lookup::unpack_lookup_constraint(lookup_constraint);
        let lhs_denom: std::math::fp2::Fp2<expr> = std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint::<expr>(lhs, alpha));
        let rhs_denom: std::math::fp2::Fp2<expr> = std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint::<expr>(rhs, alpha));
        let m_ext: std::math::fp2::Fp2<expr> = std::math::fp2::from_base::<expr>(multiplicities);
        let acc_ext: std::math::fp2::Fp2<expr> = std::math::fp2::fp2_from_array(acc);
        let next_acc: std::math::fp2::Fp2<expr> = std::math::fp2::next_ext(acc_ext);
        let update_expr: std::math::fp2::Fp2<expr> = std::math::fp2::sub_ext::<expr>(std::math::fp2::add_ext::<expr>(std::math::fp2::mul_ext::<expr>(std::math::fp2::mul_ext::<expr>(lhs_denom, rhs_denom), std::math::fp2::sub_ext::<expr>(next_acc, acc_ext)), std::math::fp2::mul_ext::<expr>(std::math::fp2::mul_ext::<expr>(m_ext, std::math::fp2::from_base::<expr>(rhs_selector)), lhs_denom)), std::math::fp2::mul_ext::<expr>(std::math::fp2::from_base::<expr>(lhs_selector), rhs_denom));
        let (acc_1, acc_2): (expr, expr) = std::math::fp2::unpack_ext::<expr>(acc_ext);
        [is_first * acc_1 = 0, is_first * acc_2 = 0] + std::math::fp2::constrain_eq_ext(update_expr, std::math::fp2::from_base::<expr>(0))
    };
    let unpack_lookup_constraint: std::prelude::Constr -> (expr, expr[], expr, expr[]) = |lookup_constraint| match lookup_constraint {
        std::prelude::Constr::Lookup((lhs_selector, rhs_selector), values) => (std::utils::unwrap_or_else::<expr>(lhs_selector, || 1), std::array::map::<(expr, expr), expr>(values, |(lhs, _)| lhs), std::utils::unwrap_or_else::<expr>(rhs_selector, || 1), std::array::map::<(expr, expr), expr>(values, |(_, rhs)| rhs)),
        _ => std::check::panic("Expected lookup constraint"),
    };
namespace std::protocols::lookup_via_bus;
    let compute_next_z_receive_lookup: expr, expr, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr, expr -> fe[] = query |is_first, id, acc, alpha, beta, lookup_constraint, multiplicities| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::lookup::unpack_lookup_constraint(lookup_constraint);
        std::protocols::bus::compute_next_z_receive(is_first, id, rhs, rhs_selector * multiplicities, acc, alpha, beta)
    };
    let compute_next_z_send_lookup: expr, expr, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr -> fe[] = query |is_first, id, acc, alpha, beta, lookup_constraint| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::lookup::unpack_lookup_constraint(lookup_constraint);
        std::protocols::bus::compute_next_z_send(is_first, id, lhs, lhs_selector, acc, alpha, beta)
    };
    let lookup: expr, expr, expr[], expr[], std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr, expr -> std::prelude::Constr[] = |is_first, id, acc_lhs, acc_rhs, alpha, beta, lookup_constraint, multiplicities| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::lookup::unpack_lookup_constraint(lookup_constraint);
        std::protocols::bus::bus_send(is_first, id, lhs, lhs_selector, acc_lhs, alpha, beta) + std::protocols::bus::bus_receive(is_first, id, rhs, rhs_selector * multiplicities, acc_rhs, alpha, beta)
    };
namespace std::protocols::permutation;
    let compute_next_z: std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr -> fe[] = query |acc, alpha, beta, permutation_constraint| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::permutation::unpack_permutation_constraint(permutation_constraint);
        let lhs_folded: std::math::fp2::Fp2<expr> = std::protocols::permutation::selected_or_one::<expr>(lhs_selector, std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint::<expr>(lhs, alpha)));
        let rhs_folded: std::math::fp2::Fp2<expr> = std::protocols::permutation::selected_or_one::<expr>(rhs_selector, std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint::<expr>(rhs, alpha)));
        let res: std::math::fp2::Fp2<fe> = std::math::fp2::mul_ext::<fe>(std::math::fp2::eval_ext(std::math::fp2::mul_ext::<expr>(acc, lhs_folded)), std::math::fp2::inv_ext(std::math::fp2::eval_ext(rhs_folded)));
        std::math::fp2::unpack_ext_array::<fe>(res)
    };
    let permutation: expr, expr[], std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr -> std::prelude::Constr[] = |is_first, acc, alpha, beta, permutation_constraint| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::permutation::unpack_permutation_constraint(permutation_constraint);
        let lhs_folded: std::math::fp2::Fp2<expr> = std::protocols::permutation::selected_or_one::<expr>(lhs_selector, std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint::<expr>(lhs, alpha)));
        let rhs_folded: std::math::fp2::Fp2<expr> = std::protocols::permutation::selected_or_one::<expr>(rhs_selector, std::math::fp2::sub_ext::<expr>(beta, std::protocols::fingerprint::fingerprint::<expr>(rhs, alpha)));
        let acc_ext: std::math::fp2::Fp2<expr> = std::math::fp2::fp2_from_array(acc);
        let next_acc: std::math::fp2::Fp2<expr> = std::math::fp2::next_ext(acc_ext);
        let update_expr: std::math::fp2::Fp2<expr> = std::math::fp2::sub_ext::<expr>(std::math::fp2::mul_ext::<expr>(rhs_folded, next_acc), std::math::fp2::mul_ext::<expr>(lhs_folded, acc_ext));
        let (acc_1, acc_2): (expr, expr) = std::math::fp2::unpack_ext::<expr>(acc_ext);
        [is_first * (acc_1 - 1) = 0, is_first * acc_2 = 0] + std::math::fp2::constrain_eq_ext(update_expr, std::math::fp2::from_base::<expr>(0))
    };
    let<T: Add + FromLiteral + Mul + Sub> selected_or_one: T, std::math::fp2::Fp2<T> -> std::math::fp2::Fp2<T> = |selector, value| std::math::fp2::add_ext::<T>(std::math::fp2::mul_ext::<T>(std::math::fp2::from_base::<T>(selector), std::math::fp2::sub_ext::<T>(value, std::math::fp2::from_base::<T>(1))), std::math::fp2::from_base::<T>(1));
    let unpack_permutation_constraint: std::prelude::Constr -> (expr, expr[], expr, expr[]) = |permutation_constraint| match permutation_constraint {
        std::prelude::Constr::Permutation((lhs_selector, rhs_selector), values) => (std::utils::unwrap_or_else::<expr>(lhs_selector, || 1), std::array::map::<(expr, expr), expr>(values, |(lhs, _)| lhs), std::utils::unwrap_or_else::<expr>(rhs_selector, || 1), std::array::map::<(expr, expr), expr>(values, |(_, rhs)| rhs)),
        _ => std::check::panic("Expected permutation constraint"),
    };
namespace std::protocols::permutation_via_bus;
    let compute_next_z_receive_permutation: expr, expr, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr -> fe[] = query |is_first, id, acc, alpha, beta, permutation_constraint| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::permutation::unpack_permutation_constraint(permutation_constraint);
        std::protocols::bus::compute_next_z_receive(is_first, id, rhs, rhs_selector, acc, alpha, beta)
    };
    let compute_next_z_send_permutation: expr, expr, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr -> fe[] = query |is_first, id, acc, alpha, beta, permutation_constraint| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::permutation::unpack_permutation_constraint(permutation_constraint);
        std::protocols::bus::compute_next_z_send(is_first, id, lhs, lhs_selector, acc, alpha, beta)
    };
    let permutation: expr, expr, expr[], expr[], std::math::fp2::Fp2<expr>, std::math::fp2::Fp2<expr>, std::prelude::Constr -> std::prelude::Constr[] = |is_first, id, acc_lhs, acc_rhs, alpha, beta, permutation_constraint| {
        let (lhs_selector, lhs, rhs_selector, rhs): (expr, expr[], expr, expr[]) = std::protocols::permutation::unpack_permutation_constraint(permutation_constraint);
        std::protocols::bus::bus_send(is_first, id, lhs, lhs_selector, acc_lhs, alpha, beta) + std::protocols::bus::bus_receive(is_first, id, rhs, rhs_selector, acc_rhs, alpha, beta)
    };
namespace std::prover;
    let challenge: int, int -> expr = constr |st, id| std::prelude::challenge(st, id);
    let degree: -> int = [];
    let eval: expr -> fe = [];
    let max_degree: -> int = [];
    let min_degree: -> int = [];
    let require_max_degree: int -> () = |m| std::check::assert(std::prover::degree() <= m, || "Degree too large.");
    let require_min_degree: int -> () = |m| std::check::assert(std::prover::degree() >= m, || "Degree too small.");
namespace std::utils;
    let cross_product: int[] -> (int -> int)[] = |sizes| std::utils::cross_product_internal(1, 0, sizes);
    let cross_product_internal: int, int, int[] -> (int -> int)[] = |cycle_len, pos, sizes| if pos >= std::array::len::<int>(sizes) { [] } else { [|i| i / cycle_len % sizes[pos]] + std::utils::cross_product_internal(cycle_len * sizes[pos], pos + 1, sizes) };
    let<T1, T2> fold: int, (int -> T1), T2, (T2, T1 -> T2) -> T2 = |length, f, initial, folder| if length <= 0 { initial } else { folder(std::utils::fold::<T1, T2>(length - 1, f, initial, folder), f(length - 1)) };
    let force_bool: expr -> std::prelude::Constr = |c| c * (1 - c) = 0;
    let is_zero: expr -> expr = constr |x| {
        let x_is_zero: col;
        std::utils::force_bool(x_is_zero);
        let x_inv: col;
        x_is_zero = 1 - x * x_inv;
        x_is_zero * x = 0;
        x_is_zero
    };
    let<T: Ord> max: T, T -> T = |a, b| if a < b { b } else { a };
    let<T: Ord> min: T, T -> T = |a, b| if a < b { a } else { b };
    let new_bool: -> expr = constr || {
        let x: col;
        std::utils::force_bool(x);
        x
    };
    let<T: Add + FromLiteral> sum: int, (int -> T) -> T = |length, f| std::utils::fold::<T, T>(length, f, 0, |acc, e| acc + e);
    let unchanged_until: expr, expr -> std::prelude::Constr = |c, latch| (c' - c) * (1 - latch) = 0;
    let<T> unwrap_or_else: std::prelude::Option<T>, (-> T) -> T = |o, f| match o {
        std::prelude::Option::None => f(),
        std::prelude::Option::Some(x) => x,
    };
namespace std::well_known;
    let is_first: int -> int = |i| if i == 0 { 1 } else { 0 };
namespace main(65536);
    col witness _operation_id;
    std::prelude::set_hint(main::_operation_id, query |i| std::prelude::Query::Hint(43));
    col fixed _block_enforcer_last_step = [0]* + [1];
    let _operation_id_no_change: expr = (1 - main::_block_enforcer_last_step) * (1 - main::instr_return);
    (1 - main::_block_enforcer_last_step) * (1 - main::instr_return) * (main::_operation_id' - main::_operation_id) = 0;
    col witness pc;
    col witness X0_1;
    col witness X0_2;
    col witness X1;
    col witness X2_1;
    col witness X2_2;
    col witness reg_write_X0_1_ALow;
    col witness reg_write_X0_2_ALow;
    col witness reg_write_X1_ALow;
    col witness reg_write_X2_1_ALow;
    col witness reg_write_X2_2_ALow;
    col witness ALow;
    col witness reg_write_X0_1_AHi;
    col witness reg_write_X0_2_AHi;
    col witness reg_write_X1_AHi;
    col witness reg_write_X2_1_AHi;
    col witness reg_write_X2_2_AHi;
    col witness AHi;
    col witness instr_shl;
    col witness instr_shr;
    col witness instr_assert_eq;
    main::instr_assert_eq * (main::X0_1 - main::X2_1) = 0;
    main::instr_assert_eq * (main::X0_2 - main::X2_2) = 0;
    col witness instr__jump_to_operation;
    col witness instr__reset;
    col witness instr__loop;
    col witness instr_return;
    col witness X0_1_const;
    col witness X0_1_read_free;
    col witness read_X0_1_AHi;
    col witness read_X0_1_ALow;
    col witness read_X0_1_pc;
    main::X0_1 = main::read_X0_1_AHi * main::AHi + main::read_X0_1_ALow * main::ALow + main::read_X0_1_pc * main::pc + main::X0_1_const + main::X0_1_read_free * main::X0_1_free_value;
    col witness X0_2_const;
    col witness X0_2_read_free;
    col witness read_X0_2_AHi;
    col witness read_X0_2_ALow;
    col witness read_X0_2_pc;
    main::X0_2 = main::read_X0_2_AHi * main::AHi + main::read_X0_2_ALow * main::ALow + main::read_X0_2_pc * main::pc + main::X0_2_const + main::X0_2_read_free * main::X0_2_free_value;
    col witness X1_const;
    col witness X1_read_free;
    col witness read_X1_AHi;
    col witness read_X1_ALow;
    col witness read_X1_pc;
    main::X1 = main::read_X1_AHi * main::AHi + main::read_X1_ALow * main::ALow + main::read_X1_pc * main::pc + main::X1_const + main::X1_read_free * main::X1_free_value;
    col witness X2_1_const;
    col witness X2_1_read_free;
    col witness read_X2_1_AHi;
    col witness read_X2_1_ALow;
    col witness read_X2_1_pc;
    main::X2_1 = main::read_X2_1_AHi * main::AHi + main::read_X2_1_ALow * main::ALow + main::read_X2_1_pc * main::pc + main::X2_1_const + main::X2_1_read_free * main::X2_1_free_value;
    col witness X2_2_const;
    col witness X2_2_read_free;
    col witness read_X2_2_AHi;
    col witness read_X2_2_ALow;
    col witness read_X2_2_pc;
    main::X2_2 = main::read_X2_2_AHi * main::AHi + main::read_X2_2_ALow * main::ALow + main::read_X2_2_pc * main::pc + main::X2_2_const + main::X2_2_read_free * main::X2_2_free_value;
    col fixed first_step = [1] + [0]*;
    main::AHi' = main::reg_write_X0_1_AHi * main::X0_1 + main::reg_write_X0_2_AHi * main::X0_2 + main::reg_write_X1_AHi * main::X1 + main::reg_write_X2_1_AHi * main::X2_1 + main::reg_write_X2_2_AHi * main::X2_2 + main::instr__reset * 0 + (1 - (main::reg_write_X0_1_AHi + main::reg_write_X0_2_AHi + main::reg_write_X1_AHi + main::reg_write_X2_1_AHi + main::reg_write_X2_2_AHi + main::instr__reset)) * main::AHi;
    main::ALow' = main::reg_write_X0_1_ALow * main::X0_1 + main::reg_write_X0_2_ALow * main::X0_2 + main::reg_write_X1_ALow * main::X1 + main::reg_write_X2_1_ALow * main::X2_1 + main::reg_write_X2_2_ALow * main::X2_2 + main::instr__reset * 0 + (1 - (main::reg_write_X0_1_ALow + main::reg_write_X0_2_ALow + main::reg_write_X1_ALow + main::reg_write_X2_1_ALow + main::reg_write_X2_2_ALow + main::instr__reset)) * main::ALow;
    col witness pc_update;
    main::pc_update = main::instr__jump_to_operation * main::_operation_id + main::instr__loop * main::pc + main::instr_return * 0 + (1 - (main::instr__jump_to_operation + main::instr__loop + main::instr_return)) * (main::pc + 1);
    main::pc' = (1 - main::first_step') * main::pc_update;
    col witness X0_1_free_value;
    col witness X0_2_free_value;
    col witness X1_free_value;
    col witness X2_1_free_value;
    col witness X2_2_free_value;
    1 $ [0, main::pc, main::reg_write_X0_1_ALow, main::reg_write_X0_2_ALow, main::reg_write_X1_ALow, main::reg_write_X2_1_ALow, main::reg_write_X2_2_ALow, main::reg_write_X0_1_AHi, main::reg_write_X0_2_AHi, main::reg_write_X1_AHi, main::reg_write_X2_1_AHi, main::reg_write_X2_2_AHi, main::instr_shl, main::instr_shr, main::instr_assert_eq, main::instr__jump_to_operation, main::instr__reset, main::instr__loop, main::instr_return, main::X0_1_const, main::X0_1_read_free, main::read_X0_1_AHi, main::read_X0_1_ALow, main::read_X0_1_pc, main::X0_2_const, main::X0_2_read_free, main::read_X0_2_AHi, main::read_X0_2_ALow, main::read_X0_2_pc, main::X1_const, main::X1_read_free, main::read_X1_AHi, main::read_X1_ALow, main::read_X1_pc, main::X2_1_const, main::X2_1_read_free, main::read_X2_1_AHi, main::read_X2_1_ALow, main::read_X2_1_pc, main::X2_2_const, main::X2_2_read_free, main::read_X2_2_AHi, main::read_X2_2_ALow, main::read_X2_2_pc] in main__rom::latch $ [main__rom::operation_id, main__rom::p_line, main__rom::p_reg_write_X0_1_ALow, main__rom::p_reg_write_X0_2_ALow, main__rom::p_reg_write_X1_ALow, main__rom::p_reg_write_X2_1_ALow, main__rom::p_reg_write_X2_2_ALow, main__rom::p_reg_write_X0_1_AHi, main__rom::p_reg_write_X0_2_AHi, main__rom::p_reg_write_X1_AHi, main__rom::p_reg_write_X2_1_AHi, main__rom::p_reg_write_X2_2_AHi, main__rom::p_instr_shl, main__rom::p_instr_shr, main__rom::p_instr_assert_eq, main__rom::p_instr__jump_to_operation, main__rom::p_instr__reset, main__rom::p_instr__loop, main__rom::p_instr_return, main__rom::p_X0_1_const, main__rom::p_X0_1_read_free, main__rom::p_read_X0_1_AHi, main__rom::p_read_X0_1_ALow, main__rom::p_read_X0_1_pc, main__rom::p_X0_2_const, main__rom::p_X0_2_read_free, main__rom::p_read_X0_2_AHi, main__rom::p_read_X0_2_ALow, main__rom::p_read_X0_2_pc, main__rom::p_X1_const, main__rom::p_X1_read_free, main__rom::p_read_X1_AHi, main__rom::p_read_X1_ALow, main__rom::p_read_X1_pc, main__rom::p_X2_1_const, main__rom::p_X2_1_read_free, main__rom::p_read_X2_1_AHi, main__rom::p_read_X2_1_ALow, main__rom::p_read_X2_1_pc, main__rom::p_X2_2_const, main__rom::p_X2_2_read_free, main__rom::p_read_X2_2_AHi, main__rom::p_read_X2_2_ALow, main__rom::p_read_X2_2_pc];
    main::instr_shl $ [0, main::X0_1, main::X0_2, main::X1, main::X2_1, main::X2_2] is main_shift16::latch * main_shift16::sel[0] $ [main_shift16::operation_id, main_shift16::ALow, main_shift16::AHi, main_shift16::B, main_shift16::CLow, main_shift16::CHi];
    main::instr_shr $ [1, main::X0_1, main::X0_2, main::X1, main::X2_1, main::X2_2] is main_shift16::latch * main_shift16::sel[1] $ [main_shift16::operation_id, main_shift16::ALow, main_shift16::AHi, main_shift16::B, main_shift16::CLow, main_shift16::CHi];
    col fixed _linker_first_step(i) { if i == 0 { 1 } else { 0 } };
    main::_linker_first_step * (main::_operation_id - 2) = 0;
namespace main__rom(65536);
    col fixed p_line = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43] + [43]*;
    col fixed p_X0_1_const = [0, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 4951, 0, 0, 0] + [0]*;
    col fixed p_X0_1_read_free = [0]*;
    col fixed p_X0_2_const = [0, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 39631, 0, 0, 0] + [0]*;
    col fixed p_X0_2_read_free = [0]*;
    col fixed p_X1_const = [0, 0, 0, 0, 1, 0, 4, 0, 8, 0, 12, 0, 16, 0, 20, 0, 24, 0, 28, 0, 31, 0, 0, 0, 1, 0, 4, 0, 8, 0, 12, 0, 16, 0, 20, 0, 24, 0, 28, 0, 31, 0, 0, 0] + [0]*;
    col fixed p_X1_read_free = [0]*;
    col fixed p_X2_1_const = [0, 0, 0, 4951, 0, 9902, 0, 13680, 0, 22272, 0, 28672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4951, 0, 35243, 0, 61749, 0, 53011, 0, 44273, 0, 39631, 0, 2476, 0, 154, 0, 9, 0, 1, 0, 0] + [0]*;
    col fixed p_X2_1_read_free = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
    col fixed p_X2_2_const = [0, 0, 0, 39631, 0, 13726, 0, 44273, 0, 53011, 0, 61749, 0, 4951, 0, 13680, 0, 22272, 0, 28672, 0, 32768, 0, 39631, 0, 19815, 0, 2476, 0, 154, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_X2_2_read_free = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
    col fixed p_instr__jump_to_operation = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_instr__loop = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] + [1]*;
    col fixed p_instr__reset = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_instr_assert_eq = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_instr_return = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0] + [0]*;
    col fixed p_instr_shl = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] + [0]*;
    col fixed p_instr_shr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
    col fixed p_read_X0_1_AHi = [0]*;
    col fixed p_read_X0_1_ALow = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_read_X0_1_pc = [0]*;
    col fixed p_read_X0_2_AHi = [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0] + [0]*;
    col fixed p_read_X0_2_ALow = [0]*;
    col fixed p_read_X0_2_pc = [0]*;
    col fixed p_read_X1_AHi = [0]*;
    col fixed p_read_X1_ALow = [0]*;
    col fixed p_read_X1_pc = [0]*;
    col fixed p_read_X2_1_AHi = [0]*;
    col fixed p_read_X2_1_ALow = [0]*;
    col fixed p_read_X2_1_pc = [0]*;
    col fixed p_read_X2_2_AHi = [0]*;
    col fixed p_read_X2_2_ALow = [0]*;
    col fixed p_read_X2_2_pc = [0]*;
    col fixed p_reg_write_X0_1_AHi = [0]*;
    col fixed p_reg_write_X0_1_ALow = [0]*;
    col fixed p_reg_write_X0_2_AHi = [0]*;
    col fixed p_reg_write_X0_2_ALow = [0]*;
    col fixed p_reg_write_X1_AHi = [0]*;
    col fixed p_reg_write_X1_ALow = [0]*;
    col fixed p_reg_write_X2_1_AHi = [0]*;
    col fixed p_reg_write_X2_1_ALow = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
    col fixed p_reg_write_X2_2_AHi = [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0] + [0]*;
    col fixed p_reg_write_X2_2_ALow = [0]*;
    col fixed operation_id = [0]*;
    col fixed latch = [1]*;
namespace main_byte_shift_16(65536);
    col fixed latch = [1]*;
    col fixed operation_id = [0]*;
    let bit_counts: int[] = [256, 32, 4, 2];
    let min_degree: int = std::array::product::<int>(main_byte_shift_16::bit_counts);
    let inputs: (int -> int)[] = std::utils::cross_product(main_byte_shift_16::bit_counts);
    let a: int -> int = main_byte_shift_16::inputs[0];
    let b: int -> int = main_byte_shift_16::inputs[1];
    let row: int -> int = main_byte_shift_16::inputs[2];
    let op: int -> int = main_byte_shift_16::inputs[3];
    let P_A: col = main_byte_shift_16::a;
    let P_B: col = main_byte_shift_16::b;
    let P_ROW: col = main_byte_shift_16::row;
    let P_operation: col = main_byte_shift_16::op;
    let c: int -> int = |i| match main_byte_shift_16::op(i) {
        0 => main_byte_shift_16::a(i) << main_byte_shift_16::b(i) + main_byte_shift_16::row(i) * 8,
        1 => main_byte_shift_16::a(i) << main_byte_shift_16::row(i) * 8 >> main_byte_shift_16::b(i),
    };
    col fixed P_CLow(i) { main_byte_shift_16::c(i) & 65535 };
    col fixed P_CHi(i) { main_byte_shift_16::c(i) >> 16 & 65535 };
namespace main_shift16(65536);
    col witness operation_id;
    (main_shift16::operation_id' - main_shift16::operation_id) * (1 - main_shift16::latch) = 0;
    col fixed latch(i) { if i % 4 == 3 { 1 } else { 0 } };
    col fixed FACTOR_ROW(i) { (i + 1) % 4 };
    col fixed FACTOR_ALow = [256, 0, 0, 1]*;
    col fixed FACTOR_AHi = [0, 1, 256, 0]*;
    col witness A_byte;
    col witness C_part_low;
    col witness C_part_hi;
    col witness ALow;
    col witness AHi;
    col witness B;
    col witness CLow;
    col witness CHi;
    main_shift16::ALow' = main_shift16::ALow * (1 - main_shift16::latch) + main_shift16::A_byte * main_shift16::FACTOR_ALow;
    main_shift16::AHi' = main_shift16::AHi * (1 - main_shift16::latch) + main_shift16::A_byte * main_shift16::FACTOR_AHi;
    (main_shift16::B' - main_shift16::B) * (1 - main_shift16::latch) = 0;
    main_shift16::CLow' = main_shift16::CLow * (1 - main_shift16::latch) + main_shift16::C_part_low;
    main_shift16::CHi' = main_shift16::CHi * (1 - main_shift16::latch) + main_shift16::C_part_hi;
    col witness sel[2];
    main_shift16::sel[0] * (1 - main_shift16::sel[0]) = 0;
    main_shift16::sel[1] * (1 - main_shift16::sel[1]) = 0;
    1 $ [0, main_shift16::operation_id', main_shift16::A_byte, main_shift16::B', main_shift16::FACTOR_ROW, main_shift16::C_part_low, main_shift16::C_part_hi] in main_byte_shift_16::latch $ [main_byte_shift_16::operation_id, main_byte_shift_16::P_operation, main_byte_shift_16::P_A, main_byte_shift_16::P_B, main_byte_shift_16::P_ROW, main_byte_shift_16::P_CLow, main_byte_shift_16::P_CHi];
