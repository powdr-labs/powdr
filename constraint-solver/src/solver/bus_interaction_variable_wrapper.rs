use std::{collections::BTreeMap, fmt::Display};

use itertools::Itertools;
use powdr_number::ExpressionConvertible;
use std::hash::Hash;

use crate::{
    constraint_system::{BusInteraction, BusInteractionHandler, ConstraintSystem},
    grouped_expression::{GroupedExpression, RangeConstraintProvider},
    range_constraint::RangeConstraint,
    runtime_constant::{ReferencedSymbols, RuntimeConstant, Substitutable, VarTransformable},
    solver::{BasicSolver, Error, ExpressionAssignment, RangeConstraints, SolveResult, Solver},
};

pub fn introduce_bus_interaction_variables<T, V, B>(
    constraint_system: ConstraintSystem<T, V>,
    bus_interaction_handler: B,
) -> impl Solver<T, V>
where
    V: Ord + Clone + Hash + Eq + Display,
    T: RuntimeConstant + VarTransformable<V, Variable<V>> + Display,
    T::Transformed: RuntimeConstant<FieldType = T::FieldType>
        + VarTransformable<Variable<V>, V, Transformed = T>
        + ReferencedSymbols<Variable<V>>
        + Substitutable<Variable<V>>
        + ExpressionConvertible<T::FieldType, Variable<V>>
        + Display,
    B: BusInteractionHandler<T::FieldType>,
{
    let mut new_constraints = Vec::new();
    let mut bus_interaction_vars = BTreeMap::new();
    let bus_interactions = constraint_system
        .bus_interactions
        .iter()
        .enumerate()
        .map(|(bus_interaction_index, bus_interaction)| {
            BusInteraction::from_iter(bus_interaction.fields().enumerate().map(
                |(field_index, expr)| {
                    let transformed_expr =
                        expr.transform_var_type(&mut |v| Variable::Variable(v.clone()));
                    let v = Variable::BusInteractionField(bus_interaction_index, field_index);
                    new_constraints.push(
                        transformed_expr - GroupedExpression::from_unknown_variable(v.clone()),
                    );
                    bus_interaction_vars.insert(v.clone(), expr.clone());
                    GroupedExpression::from_unknown_variable(v)
                },
            ))
        })
        .collect();
    let algebraic_constraints = constraint_system
        .algebraic_constraints
        .iter()
        .map(|expr| expr.transform_var_type(&mut |v| Variable::Variable(v.clone())))
        .chain(new_constraints)
        .collect();

    BusInteractionVariableWrapper {
        bus_interaction_vars,
        solver: BasicSolver::new(ConstraintSystem {
            algebraic_constraints,
            bus_interactions,
        })
        .with_bus_interaction_handler(bus_interaction_handler),
    }
}

/// A wrapped variable: Either a regular variable or a bus interaction field.
#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub enum Variable<V> {
    Variable(V),
    BusInteractionField(usize, usize),
}

impl<V: Display> Display for Variable<V> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Variable::Variable(v) => write!(f, "{v}"),
            Variable::BusInteractionField(bus_index, field_index) => {
                write!(f, "BusInteractionField({bus_index}, {field_index})")
            }
        }
    }
}

pub struct BusInteractionVariableWrapper<T: RuntimeConstant, V, S> {
    /// The definitions of the bus interaction field variables.
    bus_interaction_vars: BTreeMap<Variable<V>, GroupedExpression<T, V>>,
    /// The inner solver
    solver: S,
}

impl<T: RuntimeConstant, V: Clone, S: RangeConstraintProvider<T::FieldType, Variable<V>>>
    RangeConstraintProvider<T::FieldType, V> for BusInteractionVariableWrapper<T, V, S>
{
    fn get(&self, var: &V) -> RangeConstraint<T::FieldType> {
        self.solver.get(&Variable::Variable(var.clone()))
    }
}

impl<T: RuntimeConstant, V, S> Solver<T, V> for BusInteractionVariableWrapper<T, V, S>
where
    V: Clone + Ord + Eq + Hash,
    T: VarTransformable<V, Variable<V>> + Display,
    T::Transformed: RuntimeConstant<FieldType = T::FieldType>
        + VarTransformable<Variable<V>, V, Transformed = T>
        + Substitutable<Variable<V>>,
    S: Solver<T::Transformed, Variable<V>>,
{
    fn solve(&mut self) -> Result<(), Error> {
        self.solver.solve()
    }

    /// Returns all assignments that have not yet been returned.
    fn assignments(&mut self) -> Vec<ExpressionAssignment<T, V>> {
        let mut result = vec![];
        let assignments = self
            .solver
            .assignments()
            .into_iter()
            // The inner solver should only generate single variable assignments for now.
            .map(|(lhs, expr)| (lhs.try_to_simple_unknown().unwrap(), expr))
            .collect_vec();
        // First, apply all assignments to our stored definitions of bus interaction variables.
        for (variable, expr) in &assignments {
            if let Variable::BusInteractionField(..) = variable {
                // Non-concrete assignments are only generated by the `quadratic_equivalences` module,
                // and bus interaction fields should only appear in bus interactions and constraints
                // of the form <bus interaction field> = <expression>, which would not lead to a
                // quadratic equivalence.
                // So we only expect concrete values here, but we need to do some trickery
                // to translate types which we expect to be equal anyway.
                let value = GroupedExpression::from_number(
                    expr.try_to_known()
                        .unwrap()
                        .transform_var_type(&mut |_| unreachable!())
                        .try_to_number()
                        .unwrap(),
                );
                let original_definition = self
                    .bus_interaction_vars
                    .insert(variable.clone(), value.clone())
                    .unwrap();
                if original_definition != value {
                    // We already push these to the start of the result, i.e. we violate the order
                    // of replacement. But this is fine since we use the original definitions here,
                    // i.e. expressions in the form before any other substitutions have taken place.
                    result.push((original_definition, value));
                }
            }
        }
        // Unwrap assignments. Note that this uses the updated bus interaction field definitions.
        result.extend(assignments.into_iter().filter_map(|(v, expr)| match v {
            Variable::Variable(v) => Some((
                GroupedExpression::from_unknown_variable(v),
                unwrap_expression(&self.bus_interaction_vars, expr),
            )),
            Variable::BusInteractionField(..) => None,
        }));

        result
    }
}

impl<T, V: Ord + Clone + Hash + Eq + Display, S> BusInteractionVariableWrapper<T, V, S>
where
    T: RuntimeConstant + VarTransformable<V, Variable<V>> + Display,
    T::Transformed: RuntimeConstant<FieldType = T::FieldType>
        + VarTransformable<Variable<V>, V, Transformed = T>
        + ReferencedSymbols<Variable<V>>
        + Substitutable<Variable<V>>,
{
    pub fn finalize(
        mut self,
        solve_result: SolveResult<T::Transformed, Variable<V>>,
    ) -> SolveResult<T, V> {
        for (variable, expr) in &solve_result.assignments {
            // Apply any assignments to the bus interaction field definitions.
            if let Variable::BusInteractionField(..) = variable {
                // Non-concrete assignments are only generated by the `quadratic_equivalences` module,
                // and bus interaction fields should only appear in bus interactions and constraints
                // of the form <bus interaction field> = <expression>, which would not lead to a
                // quadratic equivalence.
                // So we only expect concrete values here, but we need to do some trickery
                // to translate types which we expect to be equal anyway.
                let value: T::FieldType = expr
                    .try_to_known()
                    .unwrap()
                    .transform_var_type(&mut |_| unreachable!())
                    .try_to_number()
                    .unwrap();
                self.bus_interaction_vars
                    .insert(variable.clone(), GroupedExpression::from_number(value));
            }
        }

        // Unwrap assignments. Note that this uses the updated bus interaction field definitions.
        let assignments = solve_result
            .assignments
            .into_iter()
            .filter_map(|(v, expr)| match v {
                Variable::Variable(v) => {
                    Some((v, unwrap_expression(&self.bus_interaction_vars, expr)))
                }
                Variable::BusInteractionField(..) => None,
            })
            .collect();

        // If a bus interaction field can be assigned a concrete value, report this to the caller.
        let bus_field_assignments = self
            .bus_interaction_vars
            .into_iter()
            .filter_map(|(v, expr)| match (v, expr.try_to_number()) {
                (Variable::BusInteractionField(bus_index, field_index), Some(value)) => {
                    Some(((bus_index, field_index), value))
                }
                _ => None,
            })
            .collect();

        let range_constraints = solve_result
            .range_constraints
            .range_constraints
            .into_iter()
            .fold(
                RangeConstraints::<T::FieldType, V>::default(),
                |mut range_constraints, (v, rc)| {
                    if let Variable::Variable(v) = v {
                        range_constraints.update(&v, &rc);
                    }
                    range_constraints
                },
            );

        SolveResult {
            assignments,
            range_constraints,
            bus_field_assignments,
        }
    }
}

fn unwrap_expression<T, V>(
    bus_interaction_vars: &BTreeMap<Variable<V>, GroupedExpression<T, V>>,
    mut expr: GroupedExpression<T::Transformed, Variable<V>>,
) -> GroupedExpression<T, V>
where
    T: RuntimeConstant + VarTransformable<V, Variable<V>> + Display,
    T::Transformed: RuntimeConstant
        + VarTransformable<Variable<V>, V, Transformed = T>
        + Substitutable<Variable<V>>,
    V: Ord + Clone + Hash + Eq,
{
    // Need to materialize because of borrow checker
    let variables = expr
        .referenced_unknown_variables()
        .filter(|v| matches!(v, Variable::BusInteractionField(..)))
        .cloned()
        .unique()
        .collect::<Vec<_>>();
    // Substitute any bus interaction fields with their definitions
    for v in variables {
        let Variable::BusInteractionField(..) = v else {
            unreachable!()
        };
        let definition = bus_interaction_vars
            .get(&v)
            .unwrap()
            .transform_var_type(&mut |v| Variable::Variable(v.clone()));
        expr.substitute_by_unknown(&v, &definition);
    }
    // Unwrap the variable type
    let expr = expr.transform_var_type(&mut |v| match v {
        Variable::Variable(v) => v.clone(),
        Variable::BusInteractionField(..) => {
            unreachable!("Bus interaction fields should have been substituted");
        }
    });
    expr
}
